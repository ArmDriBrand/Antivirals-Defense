<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Antivirals Defense</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #111; 
            color: #eee; 
            margin: 0; 
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        #game-container { 
            position: relative;
            width: 800px;
            height: 600px; 
            background: #333; 
            border: 2px solid #555; 
            overflow: hidden; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        
        canvas { 
            background: #1a1a1a;
            display: block; 
            width: 100%;
            height: auto;
        }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .screen { 
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); display: none; pointer-events: auto; z-index: 10; 
            overflow-y: auto; scrollbar-width: thin;
            scrollbar-color: #ff69b4 #333;
        }

        .screen::-webkit-scrollbar { width: 8px; }
        .screen::-webkit-scrollbar-track { background: #333; }
        .screen::-webkit-scrollbar-thumb { background: #ff69b4; border-radius: 4px; }

        #menu-screen { display: block; text-align: center; padding-top: 20px; }
        
        h1 { color: #ff69b4; font-size: 24px; text-shadow: 2px 2px #000; margin: 10px 0; }
        h2 { color: #eee; border-bottom: 1px solid #555; padding-bottom: 10px; margin-bottom: 20px; }

        .btn { background: #4caf50; border: none; padding: 6px 12px; color: white; font-size: 14px; cursor: pointer; margin: 8px; border-radius: 5px; transition: 0.2s; box-shadow: 0 4px 0 #2e7d32; }
        .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .btn:active { transform: translateY(2px); box-shadow: none; }
        
        .btn-blue { background: #2196f3; box-shadow: 0 4px 0 #1565c0; }
        .btn-purple { background: #9c27b0; box-shadow: 0 4px 0 #7b1fa2; }
        .btn-red { background: #d32f2f; box-shadow: 0 4px 0 #b71c1c; }
        .btn-gold { background: #ffd700; color: #000; box-shadow: 0 4px 0 #b8860b; }
        .btn-orange { background: #ff9800; color: #000; box-shadow: 0 4px 0 #e65100; }

        #level-grid { 
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); gap: 8px; padding: 20px; 
            max-width: 90%; margin: 0 auto;
            max-height: 60vh; overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        
        .lvl-btn { background: #444; padding: 15px 0; border-radius: 4px; cursor: pointer; border: 1px solid #666; text-align: center; position: relative; font-weight: bold; color: #888; }
        .lvl-btn.locked { opacity: 0.4; cursor: not-allowed; background: #222; }
        .lvl-btn.unlocked { background: #ff9800; color: #000; border-color: #f57c00; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); }
        .lvl-btn:hover.unlocked { background: #ffb74d; transform: scale(1.05); z-index: 2; }
        
        .daily-check { position: absolute; top: -5px; right: -5px; background: lime; color: black; border-radius: 50%; width: 18px; height: 18px; font-size: 12px; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }

        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 50px; background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0)); display: flex; justify-content: space-between; align-items: center; padding: 0 20px; box-sizing: border-box; pointer-events: none; }
        .stat { font-size: 20px; font-weight: bold; color: #fff; text-shadow: 2px 2px 0 #000; display: flex; align-items: center; gap: 5px; }

        #hero-selector { position: absolute; bottom: 0; left: 0; width: 100%; height: 65px !important; background: rgba(30,30,30,0.95); display: flex; justify-content: flex-start !important; align-items: center; pointer-events: auto; border-top: 4px solid #444; overflow-x: auto !important; overflow-y: hidden; padding: 0 10px; white-space: nowrap;    }
        
        .hero-card { 
            width: 48px !important; 
            height: 78px !important; 
            min-width: 48px !important; 
            /* Fondo con degradado oscuro met√°lico */
            background: linear-gradient(135deg, #444 0%, #222 100%);
            margin: 0 3px !important; 
            border-radius: 6px; 
            cursor: pointer; 
            position: relative; 
            text-align: center; 
            font-size: 10px !important; 
            border: 2px solid #555; /* Borde m√°s sutil por defecto */
            transition: 0.2s; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.5); 
        }

        .hero-card:hover { 
            transform: translateY(-5px); 
            border-color: #fff; 
            background: linear-gradient(135deg, #555 0%, #333 100%); /* Ligeramente m√°s claro al pasar mouse */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2); /* Resplandor */
        }

        .hero-card.selected { 
            border-color: #ffeb3b; 
            background: linear-gradient(135deg, #666 0%, #444 100%);
            box-shadow: 0 0 15px #ffeb3b; 
        }

        /* Fondo para el icono interno del h√©roe */
        .hero-icon { 
            width: 36px; 
            height: 36px; 
            margin-bottom: 2px; 
            border: 1px solid rgba(255,255,255,0.5); 
            border-radius: 4px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5); 
            /* El background-image se inyecta desde JS */
        }
        
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); color: white; font-size: 24px; font-weight: bold; display: none; justify-content: center; align-items: center; border-radius: 4px; z-index: 5; backdrop-filter: blur(2px); }
        
        .trash-btn { background: #300; border: 2px solid #500; }
        .trash-btn:hover { background: #500; border-color: red; }

        #deck-pool, #deck-selected, #draft-pool { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; margin: 10px 0; min-height: 90px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; }
        .info-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; padding-bottom: 50px; }
        .info-card { background: #333; padding: 15px; border-radius: 8px; border: 1px solid #555; text-align: left; position: relative; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .info-card h3 { margin: 5px 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .upgrade-btn { width: 100%; margin-top: 10px; font-size: 14px; padding: 8px; font-weight: bold; }

        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 20; backdrop-filter: blur(5px); }
        #overlay h2 { font-size: 60px; margin: 0; color: #ff5252; text-shadow: 4px 4px 0 #000; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #overlay p { font-size: 24px; color: #fff; margin: 20px 0; }

        #resources-bar { background: #222; padding: 10px; border-bottom: 1px solid #444; display: flex; justify-content: center; gap: 20px; font-size: 18px; color: gold; flex-wrap: wrap; align-items: center; }
        .res-item { background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px; border: 1px solid #444; }

        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <div id="ui-layer">
        <div id="hud">
            <div class="stat">‚ö° <span id="rayos-display">0</span></div>
            <div class="stat" style="color:#ff5252">üëæ <span id="enemies-display">0</span></div>
            <div class="stat">Nvl: <span id="level-display">1</span></div>
            <div class="stat" id="special-obj-display" style="display:none; color:cyan; font-size:16px;"></div>
            <div class="stat" id="limit-obj-display" style="display:none; color:orange; font-size:16px;"></div>
        </div>
        <div id="hero-selector" style="display:none;"></div>
    </div>

    <div id="menu-screen" class="screen">
        <h1>Antivirals Defense</h1>
        <div id="resources-bar">
            <div class="res-item">üí∞ <span id="menu-coins">0</span></div>
            <div class="res-item">üíµ <span id="menu-bills">0</span></div>
            <div id="daily-status" style="width:100%; margin-top:10px; font-size:14px; color:#aaa;">
                Recompensa Diaria: <span id="daily-count">0</span>/5 niveles √∫nicos
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <button class="btn" onclick="continueGame()">‚ñ∂ Jugar Nivel Actual</button>
            <button class="btn btn-gold" id="infinite-btn" style="display:none;" onclick="startInfiniteMode()">‚ôæÔ∏è Modo Infinito</button>
            <br>
            <button class="btn btn-purple" onclick="openEncyclopedia()">üìñ Enciclopedia</button>
            <button class="btn btn-blue" id="upgrades-btn" onclick="openUpgrades()">üõí Tienda / Mejoras</button>
            <br>
            <button class="btn btn-red" style="font-size: 12px; padding: 8px;" onclick="resetProgress()">‚ö† Borrar Progreso</button>
        </div>

        <div id="level-grid"></div>
    </div>

    <div id="deck-screen" class="screen">
        <h2>Elige tu Equipo (<span id="deck-count">0/6</span>)</h2>
        <div id="deck-selected"></div>
        <hr style="border-color:#444; width: 80%;">
        <p style="color:#aaa; font-size:14px;">H√©roes Disponibles</p>
        <div id="deck-pool"></div>
        <div style="margin-top: 20px;">
            <button class="btn" id="deck-confirm-btn" onclick="confirmDeck()">¬°A Defender!</button>
            <button class="btn btn-orange" id="deck-save-exit-btn" style="display:none;" onclick="saveAndExitInfinite()">üíæ Guardar y Salir</button>
            <button class="btn" id="deck-back-btn" style="background:#666" onclick="goToMenu()">Volver</button>
        </div>
    </div>
    
    <div id="draft-screen" class="screen">
        <h2>¬°Nivel Completado!</h2>
        <p style="color:#ccc;">Recluta un nuevo h√©roe para tu batall√≥n infinito</p>
        <div id="draft-pool"></div>
        <div style="margin-top:20px;">
            <p style="font-size:12px; color:#888;">Elige sabiamente, la dificultad aumentar√°.</p>
        </div>
    </div>

    <div id="encyclopedia-screen" class="screen">
        <h2>Enciclopedia</h2>
        <div style="margin: 15px 0;">
            <button class="btn btn-purple" onclick="showEncyclopediaTab('germs')">G√©rmenes</button>
            <button class="btn btn-blue" onclick="showEncyclopediaTab('heroes')">H√©roes</button>
        </div>
        <div id="pedia-content" class="info-grid" style="padding: 20px;"></div>
        <button class="btn" onclick="goToMenu()">Volver</button>
    </div>

    <div id="upgrade-screen" class="screen">
        <h2>Centro de Investigaci√≥n</h2>
        <div style="margin-bottom: 15px; background: #222; padding: 10px; border-radius: 8px; display:inline-block;">
            <span style="margin-right:15px">üí∞ <span id="shop-coins">0</span></span>
            <span>üíµ <span id="shop-bills">0</span></span>
        </div>
        
        <div style="display:flex; justify-content:center; gap:20px; margin-bottom: 20px;">
            <div style="background:#444; padding:15px; border-radius:8px; width: 220px; border: 1px solid gold; box-shadow: 0 0 10px rgba(255,215,0,0.2);">
                <h4 style="margin:0; color:gold; font-size: 18px;">MEGASOBRE</h4>
                <p style="font-size:12px; color:#ddd;">50 fichas de 4 h√©roes aleatorios.</p>
                <button class="btn btn-blue" style="font-size:14px; width:100%;" onclick="buyMegaPack()">Comprar (50üíµ)</button>
            </div>
        </div>

        <div id="heroes-upgrade-list" class="info-grid" style="padding: 20px;"></div>
        <button class="btn" onclick="goToMenu()">Volver</button>
    </div>

    <div id="overlay">
        <h2 id="overlay-title">¬°DERROTA!</h2>
        <p id="overlay-msg"></p>
        <div>
            <button class="btn" id="retry-btn" onclick="retryLevel()">Reintentar</button>
            <button class="btn btn-blue" onclick="goToMenu()">Men√∫</button>
        </div>
    </div>
</div>

<script>
/** * CONFIGURACI√ìN Y CONSTANTES */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const INTERNAL_WIDTH = 800;
const INTERNAL_HEIGHT = 400;
const CELL_W = 80, CELL_H = 80;

function resizeGame() {
    const container = document.getElementById('game-container');
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const safeMarginX = Math.max(winW * 0.05, 20); 
    let safeMarginY = Math.max(winH * 0.05, 20);
    const availableW = winW - (safeMarginX * 2);
    const availableH = winH - (safeMarginY * 2);
    const targetRatio = 800 / 600;
    const currentRatio = availableW / availableH;

    let finalW, finalH;

    if (currentRatio > targetRatio) {
        finalH = availableH;
        finalW = availableH * targetRatio;
        safeMarginY = Math.max(winH * 0.02, 10);
    } else {
        finalW = availableW;
        finalH = availableW / targetRatio;
    }

    container.style.width = `${finalW}px`;
    container.style.height = `${finalH}px`;
}

window.addEventListener('resize', resizeGame);
window.addEventListener('load', resizeGame);
resizeGame();

const HERO_NAMES = [
    "Soaphie", "Reactor", "Doblap", "Stap", "Squap", "Spenge", "ReactorDoble", "Ballge", "Ikelo", "Fuernando", "Pennfume", "Ninjap", "RunnerSoaphie", "Pastual", "Lypia", "Elenectrica", "Vampierce", "RunnerNinjap", "Knap", "Lashra", "Roostert"
];

const HEROES_INFO = {
    "Soaphie": { color: "#ff69b4", type: "shooter", desc: "Dispara burbujas b√°sicas.", reload: 5 },
    "Reactor": { color: "#00bfff", type: "producer", desc: "Genera rayos vitalizadores.", reload: 5 },
    "Doblap": { color: "#fa8072", type: "shooter", desc: "Dispara dos burbujas.", reload: 5 },
    "Stap": { color: "#8b0000", type: "8-way", desc: "Dispara en 8 direcciones.", reload: 5 },
    "Squap": { color: "#ff1493", type: "shooter", desc: "Disparos muy r√°pidos.", reload: 5 },
    "Spenge": { color: "#ffff00", type: "charge", desc: "Carga explosi√≥n. Da√±o masivo.", reload: 20 },
    "ReactorDoble": { color: "#00ced1", type: "producer", desc: "Genera rayos m√°s r√°pido.", reload: 5 },
    "Ballge": { color: "#ffa500", type: "ball", desc: "Se lanza como bola de boliche.", reload: 5 },
    "Ikelo": { color: "#a5f2f3", type: "shooter_ice", desc: "Congela enemigos. Da√±o extra a Fuego.", reload: 5 },
    "Fuernando": { color: "#ff4500", type: "shooter_fire", desc: "Quema y derrite hielo.", reload: 5 },
    "Pennfume": { color: "#d8bfd8", type: "shooter_slow", desc: "Perfume que ralentiza (perforante).", reload: 5 },
    "Ninjap": { color: "#333333", type: "ninja", desc: "Alterna disparo en cruz o X. Alta vida.", reload: 10 },
    "RunnerSoaphie": { color: "#ff1493", type: "runner", desc: "Corre y golpea o dispara de lejos.", reload: 5 },
    "Pastual": { color: "#88cc88", type: "passive_slow", desc: "Ralentiza a quien lo pisa.", reload: 20 },
    "Lypia": { color: "#aa00ff", type: "laser", desc: "Dispara l√°ser perforante.", reload: 5 },
    "Elenectrica": { color: "#ffff33", type: "electric", desc: "Bolas perforantes. 25% de dar Sol al impactar.", reload: 5 },
    "Vampierce": { color: "#800080", type: "aura", desc: "Cura sangre a g√©rmenes cercanos. Inmune a control.", reload: 5 },
    "RunnerNinjap": { color: "#111", type: "ninja_switch", desc: "C1-6: Disparo Fuerte. C7-10: Disparo 8 dir.", reload: 5 },
    "Knap": { color: "#8d6e63", type: "melee_knock", desc: "Empuja enemigos. Puedes poner otro h√©roe encima.", reload: 10 },
    "Lashra": { color: "#e91e63", type: "explosive_spike", desc: "P√∫as con prob. de explosi√≥n.", reload: 5 },
    "Roostert": { color: "#d35400", type: "roostert_blade", desc: "Instakill a la mayor√≠a de enemigos.", reload: 5 },
    // Objetos especiales (No comprables, solo para niveles espec√≠ficos)
    "CatapultaEspuma": { color: "#fff", type: "catapult", desc: "No jugable. Lanza espuma cada 2s.", hp: 500 },
    "CatapultaHielo": { color: "#a5f2f3", type: "catapult_ice", desc: "No jugable. Congela el suelo.", hp: 500 },
};

const heroSprites = {};

const ScenaryURLs = {
    range1: "https://i.postimg.cc/MpQqv6gZ/Houston_Escenario.jpg",
    range2: "https://i.postimg.cc/2SZrVkg8/San_Francisco_Escenario.jpg",
    range3: "https://i.postimg.cc/fR9DJz1z/Tijuana_Escenario.jpg",
    range4: "https://i.postimg.cc/rwrMKV7w/Tokio_Escenario.jpg",
    range5: "https://i.postimg.cc/wBYHJKdK/Budapest_Escenario.jpg"
};

// Variable para guardar la imagen actual cargada
let currentBgImage = new Image();

function updateBackground(level) {
    let url = "";
    // L√≥gica de rangos
    if (level <= 10) url = ScenaryURLs.range1;
    else if (level <= 18) url = ScenaryURLs.range2;
    else if (level <= 36) url = ScenaryURLs.range3;
    else if (level <= 54) url = ScenaryURLs.range4;
    else url = ScenaryURLs.range5;

    // Solo recargar si la URL cambia
    if (currentBgImage.src !== url) {
        currentBgImage.src = url;
        currentBgImage.crossOrigin = "anonymous";
    }
}

const spriteUrls = {
    "Soaphie": "https://i.postimg.cc/RVBPcB5b/Soaphie.png",
    "Reactor": "https://i.postimg.cc/KvD0fHx9/Reactor.png",
    "Doblap": "https://i.postimg.cc/fLMLcyKv/Doblap.png",
    "Squap": "https://i.postimg.cc/wvNCjQLM/Squap.png",
    "Stap": "https://i.postimg.cc/gJhC2H8r/Stap.png",
    "Spenge": "https://i.postimg.cc/RhVBFnRB/Spenge.png",
    "ReactorDoble": "https://i.postimg.cc/26rCg5V9/Reactor-doble.png",
    "Ballge": "https://i.postimg.cc/zBkN8kTp/Ballge.png",
    "Ikelo": "https://i.postimg.cc/0QCvPC7F/Ikelo.png",
    "Fuernando": "https://i.postimg.cc/LXVS2Vjc/Fuernando.png",
    "Pennfume": "https://i.postimg.cc/Wzbv3J7C/Pennfume.png",
    "Ninjap": "https://i.postimg.cc/PxMHTMmT/Ninjap.png",
    "RunnerSoaphie": "https://i.postimg.cc/brNhJ2TX/Runner_Soaphie.png",
    "Pastual": "https://i.postimg.cc/V6FwmFj8/Pastual.png",
    "Lypia": "https://i.postimg.cc/pTBvRBDN/Lypia.png",
    "Elenectrica": "https://i.postimg.cc/254HhvWC/Elen√©ctrica.png",
    "Vampierce": "https://i.postimg.cc/pXhvFWWb/Vampierce.png",
    "RunnerNinjap": "https://i.postimg.cc/cJQDwY3L/Runner_Ninjap.png",
    "Knap": "https://i.postimg.cc/6QdHnRZW/Knap.png",
    "Lashra": "https://i.postimg.cc/mrQdCM9Z/Lashra.png",
    "Roostert": "https://i.postimg.cc/J4fL3fnp/Roostert.png",
    "CatapultaEspuma": "https://i.postimg.cc/V6CTN69R/Catapulta_de_espuma.png",
    "CatapultaHielo": "https://i.postimg.cc/1tqTzt0J/Catapulta_de_hielo.png",
};

const ballgeRollUrl = "https://i.postimg.cc/HnsYWGJ1/Ballge_rolling.png"; "; 
const ballgeRollSprite = new Image();
ballgeRollSprite.crossOrigin = "anonymous";
ballgeRollSprite.src = ballgeRollUrl;

Object.keys(spriteUrls).forEach(name => {
    const img = new Image();
    img.crossOrigin = "anonymous"; 
    img.src = spriteUrls[name];
    heroSprites[name] = img;
});

const enemyFrames = {}; // Aqu√≠ se guardar√°n las im√°genes ya cargadas

// PEGA TUS ENLACES AQU√ç. A√±ade tantos frames como tengas.
const ENEMY_ANIMATIONS_URLS = {
    "Normal": [
        "https://i.postimg.cc/HxjyGCc2/Germen_normal.png",
        "https://i.postimg.cc/k4Dbrd6w/Germen_normal_caminando_1.png", 
        "https://i.postimg.cc/4dn9CT7B/Germen_normal_caminando_2.png",
        "https://i.postimg.cc/k4Dbrd6w/Germen_normal_caminando_1.png",
        "https://i.postimg.cc/HxjyGCc2/Germen_normal.png",
        "https://i.postimg.cc/ZR0dkhBw/Germen_normal_caminando_3.png",
        "https://i.postimg.cc/3RWvMH4S/Germen_normal_caminando_4.png",
        "https://i.postimg.cc/ZR0dkhBM/Germen_normal_caminando_5.png",
        "https://i.postimg.cc/3RWvMH4S/Germen_normal_caminando_4.png",
        "https://i.postimg.cc/ZR0dkhBw/Germen_normal_caminando_3.png",
    ],
    "Sangre": [
        "https://i.postimg.cc/HLSrtsWy/Germen_ensangrentado.png",
        "https://i.postimg.cc/JhTsQ47J/Germen_ensangrentado_caminando_1.png", 
        "https://i.postimg.cc/CKvR4LMf/Germen_ensangrentado_caminando_2.png",
        "https://i.postimg.cc/JhTsQ47J/Germen_ensangrentado_caminando_1.png",
        "https://i.postimg.cc/HLSrtsWy/Germen_ensangrentado.png",
        "https://i.postimg.cc/ZqfWLKYN/Germen_ensangrentado_caminando_3.png",
        "https://i.postimg.cc/W49d7bpw/Germen_ensangrentado_caminando_4.png",
        "https://i.postimg.cc/vmP4vH8v/Germen_ensangrentado_caminando_5.png",
        "https://i.postimg.cc/W49d7bpw/Germen_ensangrentado_caminando_4.png",
        "https://i.postimg.cc/ZqfWLKYN/Germen_ensangrentado_caminando_3.png",
    ],
    "MasSangre": [
        "https://i.postimg.cc/g22dHyw0/Germen_a√∫n_m√°s_ensangrentado.png",
        "https://i.postimg.cc/wjjHQ5tj/Germen_a√∫n_m√°s_ensangrentado_caminando_1.png", 
        "https://i.postimg.cc/P55hQbLJ/Germen_a√∫n_m√°s_ensangrentado_caminando_2.png",
        "https://i.postimg.cc/wjjHQ5tj/Germen_a√∫n_m√°s_ensangrentado_caminando_1.png",
        "https://i.postimg.cc/g22dHyw0/Germen_a√∫n_m√°s_ensangrentado.png",
        "https://i.postimg.cc/2SSm7dq6/Germen_a√∫n_m√°s_ensangrentado_caminando_3.png",
        "https://i.postimg.cc/Bn73Y8D4/Germen_a√∫n_m√°s_ensangrentado_caminando_4.png",
        "https://i.postimg.cc/VkZwGSM1/Germen_a√∫n_m√°s_ensangrentado_caminando_5.png",
        "https://i.postimg.cc/Bn73Y8D4/Germen_a√∫n_m√°s_ensangrentado_caminando_4.png",
        "https://i.postimg.cc/2SSm7dq6/Germen_a√∫n_m√°s_ensangrentado_caminando_3.png",
    ],
    "Resortera": [
        "https://i.postimg.cc/CMHJBzqn/Resortera_Germen.png",
    ];
    "Acuatico": [
        "https://i.postimg.cc/2y3vRLy7/Germen_acu√°tico.png",
        "https://i.postimg.cc/WzKZ2pqg/Germen_acu√°tico_caminando_1.png", 
        "https://i.postimg.cc/7hczxPJg/Germen_acu√°tico_caminando_2.png",
        "https://i.postimg.cc/WzKZ2pqg/Germen_acu√°tico_caminando_1.png",
        "https://i.postimg.cc/2y3vRLy7/Germen_acu√°tico.png",
        "https://i.postimg.cc/qqYKkB6s/Germen_acu√°tico_caminando_3.png",
        "https://i.postimg.cc/zvMhJDHS/Germen_acu√°tico_caminando_4.png",
        "https://i.postimg.cc/MH4BWZfm/Germen_acu√°tico_caminando_5.png",
        "https://i.postimg.cc/zvMhJDHS/Germen_acu√°tico_caminando_4.png",
        "https://i.postimg.cc/qqYKkB6s/Germen_acu√°tico_caminando_3.png",
    ],
    "Fuego": [
        "https://i.postimg.cc/L57PH4gx/Germen_de_fuego.png",
        "https://i.postimg.cc/90S9WXwg/Germen_de_fuego_caminando_1.png", 
        "https://i.postimg.cc/SR59yQYt/Germen_de_fuego_caminando_2.png",
        "https://i.postimg.cc/90S9WXwg/Germen_de_fuego_caminando_1.png",
        "https://i.postimg.cc/L57PH4gx/Germen_de_fuego.png",
        "https://i.postimg.cc/gj5hYcLT/Germen_de_fuego_caminando_3.png",
        "https://i.postimg.cc/zvMhJDH6/Germen_de_fuego_caminando_4.png",
        "https://i.postimg.cc/C5t8FMfT/Germen_de_fuego_caminando_5.png",
        "https://i.postimg.cc/zvMhJDH6/Germen_de_fuego_caminando_4.png",
        "https://i.postimg.cc/gj5hYcLT/Germen_de_fuego_caminando_3.png",
    ],
    "Hielo": [
        "https://i.postimg.cc/Rh8tMCnz/Germen_de_hielo.png",
        "https://i.postimg.cc/ZYDpPHsY/Germen_de_hielo_caminando_1.png", 
        "https://i.postimg.cc/PfFYbyV5/Germen_de_hielo_caminando_2.png",
        "https://i.postimg.cc/ZYDpPHsY/Germen_de_hielo_caminando_1.png",
        "https://i.postimg.cc/Rh8tMCnz/Germen_de_hielo.png",
        "https://i.postimg.cc/661nVcbQ/Germen_de_hielo_caminando_3.png",
        "https://i.postimg.cc/v8Sf7h2T/Germen_de_hielo_caminando_4.png",
        "https://i.postimg.cc/1RYw0B74/Germen_de_hielo_caminando_5.png",
        "https://i.postimg.cc/v8Sf7h2T/Germen_de_hielo_caminando_4.png",
        "https://i.postimg.cc/661nVcbQ/Germen_de_hielo_caminando_3.png",
    ],
    "Succionador": [
        "https://i.postimg.cc/L40LkDQn/Germen_succionador.png",
        "https://i.postimg.cc/59kL5gKX/Germen_succionador_caminando_1.png", 
        "https://i.postimg.cc/DfYLQ6pW/Germen_succionador_caminando_2.png",
        "https://i.postimg.cc/59kL5gKX/Germen_succionador_caminando_1.png",
        "https://i.postimg.cc/L40LkDQn/Germen_succionador.png",
        "https://i.postimg.cc/J7dZ3xYD/Germen_succionador_caminando_3.png",
        "https://i.postimg.cc/G3SGPKgT/Germen_succionador_caminando_4.png",
        "https://i.postimg.cc/ZYDpPHsy/Germen_succionador_caminando_5.png",
        "https://i.postimg.cc/G3SGPKgT/Germen_succionador_caminando_4.png",
        "https://i.postimg.cc/J7dZ3xYD/Germen_succionador_caminando_3.png",
    ],
}
Object.keys(ENEMY_ANIMATIONS_URLS).forEach(type => {
    enemyFrames[type] = []; // Crear array para este tipo
    ENEMY_ANIMATIONS_URLS[type].forEach(url => {
        const img = new Image();
        img.src = url;
        img.crossOrigin = "anonymous";
        enemyFrames[type].push(img);
    });
});
const ENEMIES_DATA = {
    "Normal": { hp: 100, speed: 0.15, color: "#333", damage: 20 },
    "Sangre": { hp: 200, speed: 0.15, color: "#800000", damage: 20 },
    "MasSangre": { hp: 300, speed: 0.15, color: "#400000", damage: 20 },
    "Resortera": { hp: 300, speed: 0, color: "#4a2c2a", damage: 0 },
    "Super": { hp: 2000, speed: 0.15, color: "#000", damage: 9999 },
    "Acuatico": { hp: 150, speed: 0.15, color: "#00008b", damage: 20, isAquatic: true },
    "Fuego": { hp: 100, speed: 0.30, color: "#ff5722", damage: 9999, isFire: true },
    "Hielo": { hp: 200, speed: 0.15, color: "#00bcd4", damage: 20, isIce: true },
    "Succionador": { hp: 250, speed: 0.15, color: "#8e24aa", damage: 20, isSucker: true },
    "Teleporter": { hp: 100, speed: 0.15, color: "#00ff00", damage: 9999, isTeleporter: true },
    "SuperRojo": { hp: 4000, speed: 0.225, color: "#ff0000", damage: 9999 },
    "Vampiro": { hp: 200, speed: 0.30, color: "#4b0082", damage: 20, isVampire: true },
    "Elastico": { hp: 300, speed: 0.15, color: "#ff69b4", damage: 25, isElastic: true },
    "Velocista": { hp: 500, speed: 0.15, color: "#ffff00", damage: 20, isSpeedster: true },
    "Controlador": { hp: 250, speed: 0.15, color: "#2e7d32", damage: 20, isController: true }
};

const LEVELS = [
    { count: 10, rate: 800, pool: ["Normal"] },
    { count: 15, rate: 750, pool: ["Normal", "Sangre"] },
    { count: 20, rate: 700, pool: ["Normal", "Sangre"] },
    { count: 25, rate: 650, pool: ["Normal", "Sangre"] },
    { count: 30, rate: 600, pool: ["Normal", "Sangre", "MasSangre"] },
    { count: 30, rate: 550, pool: ["Normal", "Sangre", "MasSangre", "Resortera"] },
    { count: 35, rate: 500, pool: ["Normal", "Sangre", "MasSangre", "Resortera"] },
    { count: 35, rate: 450, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super"] },
    { count: 35, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super"] },
    { count: 1, rate: 300, pool: ["Boss"] }, // Level 10
    { count: 35, rate: 450, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Acuatico"] },
    { count: 40, rate: 450, pool: ["Normal", "Sangre", "MasSangre", "Super", "Acuatico"] },
    { count: 35, rate: 500, pool: ["Normal", "Sangre", "Acuatico"], objective: "produce50" },
    { count: 50, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico"] },
    { count: 50, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico"], deckLimit: true },
    { count: 40, rate: 400, pool: ["Normal", "Sangre", "MasSangre"], fixedDeck: ["Reactor", "ReactorDoble", "Squap"] },
    { count: 35, rate: 400, pool: ["Normal", "Sangre", "Super"], fixedDeck: ["Reactor", "Soaphie", "Ballge"], objective: "saveHeroes" },
    { count: 1, rate: 100, pool: ["BossGegion"], fixedDeck: ["ReactorDoble", "Doblap", "Squap", "Spenge", "Ballge"] }, // Level 18
    { count: 45, rate: 400, pool: ["Normal", "Sangre", "Fuego"], deckLimit: true },
    { count: 40, rate: 400, pool: ["Normal", "Fuego"], fixedDeck: ["ReactorDoble", "Soaphie", "Ikelo"] },
    { count: 50, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Acuatico", "Fuego"], objective: "produce150", deckLimit: true },
    { count: 30, rate: 600, pool: ["Normal"], constraint: "spendMax40" },
    { count: 50, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Acuatico", "Fuego"], constraint: "spendMax150" },
    { count: 60, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico", "Fuego"], constraint: "maxHeroes20" },
    { count: 45, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Hielo"], fixedDeck: ["ReactorDoble", "Squap", "Fuernando"] },
    { count: 50, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Hielo", "Fuego"] },
    { count: 45, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera"], objective: "saveHeroes10" },
    { count: 55, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico", "Hielo", "Fuego"] },
    { count: 30, rate: 300, pool: ["Fuego"], fixedDeck: ["ReactorDoble", "Ikelo"], startRays: 50 },
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Super", "Hielo"], fixedDeck: ["ReactorDoble", "Fuernando", "Pennfume"] },
    { count: 45, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Resortera"], objective: "saveHeroes5" },
    { count: 50, rate: 380, pool: ["Normal", "Sangre", "MasSangre"], objective: "distanceKill10" },
    { count: 50, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Acuatico", "Succionador"] },
    { count: 55, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Acuatico", "Succionador"], objective: "saveHeroes15" },
    { count: 65, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico", "Hielo", "Fuego", "Succionador"] },
    { count: 1, rate: 100, pool: ["BossFinal"], fixedDeck: ["ReactorDoble", "Soaphie", "Ballge", "Ikelo", "Fuernando", "Pennfume"] }, // Level 36
    { count: 45, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Teleporter"] },
    { count: 40, rate: 400, pool: ["Normal", "Sangre", "MasSangre", "Teleporter"], fixedDeck: ["ReactorDoble", "Ninjap"], forbiddenRows: [1, 3] },
    { count: 50, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Teleporter"], objective: "saveHeroes15" },
    { count: 60, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico", "Hielo", "Fuego", "Succionador", "Teleporter"], constraint: "maxHeroes20" },
    { count: 50, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Acuatico", "Fuego"], specialObj: "protectReactorsCol6", startSetup: "level41" },
    { count: 45, rate: 350, pool: ["MasSangre", "Teleporter", "Super"], specialObj: "protectSquapsCol1", startSetup: "level42" },
    { count: 50, rate: 380, pool: ["MasSangre", "Acuatico"], fixedDeck: ["Soaphie", "Doblap", "Stap", "Squap", "Ballge", "Ikelo"], startRays: 175, noProduction: true },
    { count: 45, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Resortera"], fixedDeck: ["ReactorDoble", "RunnerSoaphie"] },
    { count: 50, rate: 380, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Acuatico"], specialObj: "protectRunnersSpecific", startSetup: "level45" },
    { count: 30, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Acuatico", "Super"], fixedDeck: ["Reactor", "Doblap", "Squap"], forbiddenCols: [4,5,6,7,8,9], startSetup: "20Soaphies" },
    { count: 40, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico"], fixedDeck: ["Ballge"], startSetup: "col0Reactors" },
    { count: 45, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Super", "Fuego"], fixedDeck: ["ReactorDoble", "Ballge", "Pastual"] },
    { count: 20, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Fuego", "Super", "SuperRojo"], fixedDeck: ["ReactorDoble", "Soaphie", "Squap", "Pennfume", "Ikelo", "Pastual"], objective: "distanceKill10_Cols8910" },
    { count: 60, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Fuego", "Teleporter", "Super", "SuperRojo"], fixedDeck: ["Ballge"], startSetup: "PastualDefense" },
    { count: 45, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Resortera"], fixedDeck: ["ReactorDoble", "Pennfume", "Lypia"] },
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Acuatico", "Succionador"], fixedDeck: ["ReactorDoble", "Ninjap"], specialObj: "protectLypiasCol1", startSetup: "level52" },
    { count: 70, rate: 280, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico", "Hielo", "Fuego", "Succionador", "Teleporter"] },
    { count: 1, rate: 100, pool: ["BossGegionV2"], fixedDeck: ["ReactorDoble", "Pennfume", "Ninjap", "RunnerSoaphie", "Pastual", "Lypia"] }, // Level 54
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Vampiro"] }, // 55
    { count: 55, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Vampiro"], objective: "produce750", fixedDeck: ["Reactor", "Elenectrica"] }, // 56
    { count: 40, rate: 350, pool: ["Normal", "Super", "SuperRojo"], fixedDeck: ["Squap", "Fuernando"], startSetup: "level57" }, // 57
    { count: 60, rate: 300, pool: ["Normal", "MasSangre"], fixedDeck: ["ReactorDoble", "Squap"], forbiddenCols: [6,7,8,9], startSetup: "level58" }, // 58
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Vampiro"], fixedDeck: ["ReactorDoble", "Soaphie", "Vampierce"] }, // 59
    { count: 65, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Hielo", "Fuego", "Vampiro"], fixedDeck: ["Ballge"], startSetup: "level60" }, // 60
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Hielo", "Fuego", "Vampiro"], startRays: 100, noProduction: true }, // 61
    { count: 45, rate: 350, pool: ["Normal", "Sangre", "MasSangre"], fixedDeck: ["ReactorDoble", "Soaphie"], startSetup: "level62" }, // 62
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Fuego"], fixedDeck: ["ReactorDoble", "Soaphie", "Ikelo"], startSetup: "level63" }, // 63
    { count: 40, rate: 300, pool: ["Succionador"], constraint: "maxHeroes5", startSetup: "level64" }, // 64
    { count: 45, rate: 350, pool: ["Normal", "Super"], fixedDeck: ["ReactorDoble", "Soaphie", "RunnerNinjap"] }, // 65
    { count: 60, rate: 320, pool: ["Normal", "Sangre", "MasSangre", "Super"], fixedDeck: ["RunnerNinjap"], startSetup: "level66", forbiddenCols: [3,4,5] }, // 66
    { count: 55, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Acuatico", "Teleporter", "Elastico"] }, // 67
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Hielo"], fixedDeck: ["ReactorDoble", "Knap"], constraint: "maxHeroes20" }, // 68
    { count: 60, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Hielo", "Fuego", "Super"], fixedDeck: ["ReactorDoble", "Squap", "Knap"], constraint: "maxHeroes40", forbiddenCols: [4,5,6,7,8,9] }, // 69
    { count: 30, rate: 400, pool: ["Resortera"], fixedDeck: ["Elenectrica"], forbiddenCols: [5,6,7,8,9], startSetup: "level70" }, // 70
    { count: 40, rate: 350, pool: ["Normal"], fixedDeck: ["ReactorDoble", "Soaphie", "Knap"], forbiddenCols: [1,2,3,4,5,6,7,8,9] }, // 71
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre"], startSetup: "level72" }, // 72 (M√°quinas)
    { count: 55, rate: 300, pool: ["Normal"], startSetup: "level73" }, // 73
    { count: 40, rate: 350, pool: ["Normal"], fixedDeck: ["ReactorDoble", "Lashra", "Lypia"], startSetup: "level74" }, // 74
    { count: 60, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Teleporter", "Super"], fixedDeck: ["Pennfume", "Lypia", "Lashra"], startRays: 125, noProduction: true }, // 75
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "MasSangre", "Controlador"] }, // 76
    { count: 45, rate: 350, pool: ["Controlador", "Vampiro"], fixedDeck: ["ReactorDoble", "Squap", "Spenge", "Fuernando", "RunnerNinjap"] }, // 77
    { count: 60, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Controlador", "Vampiro"], constraint: "maxLost15" }, // 78
    { count: 55, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Fuego", "Velocista"] }, // 79
    { count: 55, rate: 300, pool: ["Normal", "Sangre", "MasSangre", "Fuego", "Velocista"], fixedDeck: ["ReactorDoble", "Pennfume", "Lashra"] }, // 80
    { count: 50, rate: 350, pool: ["Normal", "Sangre", "Resortera", "Super"], fixedDeck: ["ReactorDoble", "Doblap", "Roostert"] }, // 81
    { count: 50, rate: 350, pool: ["Normal", "MasSangre", "Super"], fixedDeck: ["Roostert", "Squap"], startRays: 175, noProduction: true }, // 82
    { count: 30, rate: 400, pool: ["SuperRojo"], fixedDeck: ["Ballge"], startSetup: "level83" }, // 83
    { count: 45, rate: 350, pool: ["Super", "SuperRojo"], fixedDeck: ["ReactorDoble", "Ballge", "Roostert"] }, // 84
    { count: 80, rate: 250, pool: ["Normal", "Sangre", "MasSangre", "Resortera", "Super", "Acuatico", "Hielo", "Fuego", "Succionador", "Teleporter", "SuperRojo", "Vampiro", "Elastico", "Controlador", "Velocista"] }, // 85
    { count: 1, rate: 100, pool: ["BossGegionFinal"], fixedDeck: ["ReactorDoble", "Roostert", "Vampierce", "RunnerNinjap", "Knap", "Lashra"] } // 86 (Final Boss)
];

let gameState = {
    mode: 'story', // 'story' or 'infinite'
    rayos: 2, level: 1, maxLevel: 1,
    enemiesToSpawn: 0, totalEnemies: 0,
    gameOver: false, selectedHero: null, spawnTimer: 0,
    availableHeroes: [], currentDeck: [],
    hasTrash: false, isTrashing: false, trashUpgrade: false, trashUpgrade2: false,
    bossHP: 0, machines: [], timerRayo: 20,
    deckLimit7: false,
    producedRaysCount: 0, heroesLostCount: 0, superSpawned: 0, raysSpent: 0,
    killObjCount: 0, killObjFailed: false, bossStartedSpawning: false, levelFrame: 0,
    coins: 0, bills: 0,
    inventory: {},
    dailyPlayed: [],
    lastDate: "",
    heroCurrentReloads: {},
    
    // Infinite Mode Data
    infinite: {
        active: false,
        wave: 1,
        deck: [], // Mazo activo (max 6-7)
        pool: ["Reactor", "Soaphie"], // Todos los h√©roes disponibles para elegir
        pendingCoins: 0,
        pendingBills: 0,
        savedBoard: [] // Nuevo: para persistir la defensa
    }
};

HERO_NAMES.forEach(name => {
    if (!gameState.inventory[name]) gameState.inventory[name] = { level: 1, chips: 0 };
});

let heroes = [], enemies = [], projectiles = [], popups = [];

/** * SISTEMA DE GUARDADO Y CARGA */
const SAVE_VERSION = 11; // Version Bump
function saveProgress() {
    const saveData = { 
        version: SAVE_VERSION, 
        maxLevel: gameState.maxLevel,
        coins: gameState.coins,
        bills: gameState.bills,
        inventory: gameState.inventory,
        dailyPlayed: gameState.dailyPlayed,
        lastDate: gameState.lastDate,
        infinite: gameState.infinite
    };
    localStorage.setItem('AntiviralsDefenseSave', JSON.stringify(saveData));
    updateMenuResources();
}

function loadProgress() {
    const saved = localStorage.getItem('AntiviralsDefenseSave');
    if (saved) {
        const data = JSON.parse(saved);
        gameState.maxLevel = data.maxLevel || 1;
        gameState.coins = data.coins || 0;
        gameState.bills = data.bills || 0;
        gameState.dailyPlayed = data.dailyPlayed || [];
        gameState.lastDate = data.lastDate || "";
        gameState.infinite = data.infinite || { 
            active: false, wave: 1, deck: [], pool: ["Reactor", "Soaphie"], pendingCoins: 0, pendingBills: 0, savedBoard: [] 
        };
        // Compatibilidad hacia atr√°s si faltan campos
        if(!gameState.infinite.pool) gameState.infinite.pool = ["Reactor", "Soaphie"];
        if(!gameState.infinite.deck) gameState.infinite.deck = ["Reactor", "Soaphie"];
        if(!gameState.infinite.savedBoard) gameState.infinite.savedBoard = [];

        HERO_NAMES.forEach(name => {
            if (data.inventory && data.inventory[name]) {
                gameState.inventory[name] = data.inventory[name];
            } else {
                gameState.inventory[name] = { level: 1, chips: 0 };
            }
        });
    } else {
        gameState.maxLevel = 1;
        gameState.coins = 0;
        gameState.bills = 0;
        gameState.dailyPlayed = [];
        gameState.lastDate = "";
        HERO_NAMES.forEach(name => gameState.inventory[name] = { level: 1, chips: 0 });
    }
    
    const today = new Date().toDateString();
    if (gameState.lastDate !== today) {
        gameState.dailyPlayed = [];
        gameState.lastDate = today;
        saveProgress();
    }

    checkUnlocks(gameState.maxLevel);
    updateMenuResources();
    updateUpgradesButton();
    updateInfiniteButton();
}

function resetProgress() {
    if(confirm("¬øSeguro que quieres borrar todo el progreso? Se perder√°n niveles y mejoras.")) {
        localStorage.removeItem('AntiviralsDefenseSave');
        location.reload();
    }
}

/** * GESTI√ìN DE RECURSOS Y UI MENU */
function updateMenuResources() {
    document.getElementById('menu-coins').innerText = gameState.coins;
    document.getElementById('menu-bills').innerText = gameState.bills;
    document.getElementById('shop-coins').innerText = gameState.coins;
    document.getElementById('shop-bills').innerText = gameState.bills;
    document.getElementById('daily-count').innerText = gameState.dailyPlayed.length;
}

function updateUpgradesButton() {
    const btn = document.getElementById('upgrades-btn');
    btn.disabled = false;
    btn.onclick = openUpgrades;
}

function updateInfiniteButton() {
    const btn = document.getElementById('infinite-btn');
    if (gameState.maxLevel >= 19) {
        btn.style.display = 'inline-block';
        if (gameState.infinite.active) {
            btn.innerText = `‚ôæÔ∏è Continuar Infinito (Ola ${gameState.infinite.wave})`;
        } else {
            btn.innerText = `‚ôæÔ∏è Modo Infinito`;
        }
    } else {
        btn.style.display = 'none';
    }
}

function giveChips(heroName, amount) {
    if (gameState.inventory[heroName]) {
        gameState.inventory[heroName].chips += amount;
    }
}

function giveMiniPack() {
    const unlockedHeroes = gameState.availableHeroes;
    if (unlockedHeroes.length === 0) return;
    let h1 = unlockedHeroes[Math.floor(Math.random() * unlockedHeroes.length)];
    let h2 = unlockedHeroes[Math.floor(Math.random() * unlockedHeroes.length)];
    giveChips(h1, 3);
    giveChips(h2, 4);
    alert(`¬°Recompensa Diaria!\nMinisobre obtenido:\n3 fichas de ${h1}\n4 fichas de ${h2}`);
    saveProgress();
}

function openPack(isMega) {
    let chipsGiven = [];
    const unlockedHeroes = gameState.availableHeroes;
    if (!unlockedHeroes || unlockedHeroes.length === 0) return;
    if (isMega) {
        for(let i=0; i<4; i++) {
            let h = unlockedHeroes[Math.floor(Math.random() * unlockedHeroes.length)];
            giveChips(h, 50);
            chipsGiven.push(`50 ${h}`);
        }
    } else {
        for(let i=0; i<2; i++) {
            let h = unlockedHeroes[Math.floor(Math.random() * unlockedHeroes.length)];
            giveChips(h, 10);
            chipsGiven.push(`10 ${h}`);
        }
    }
    saveProgress();
    alert(isMega ? `¬°MEGASOBRE ABIERTO!\nConseguiste:\n${chipsGiven.join('\n')}` : `¬°Sobre abierto!\nConseguiste:\n${chipsGiven.join('\n')}`);
    if (document.getElementById('upgrade-screen').style.display === 'block') {
        renderUpgradeList();
    }
}

function buyMegaPack() {
    if (gameState.bills >= 50) {
        gameState.bills -= 50;
        openPack(true);
        updateMenuResources();
    } else {
        alert("No tienes suficientes billetes (50).");
    }
}

function upgradeHero(name) {
    let heroData = gameState.inventory[name];
    if (heroData.level >= 10) return alert("¬°Nivel m√°ximo alcanzado!");
    if (heroData.chips >= 200 && gameState.coins >= 2500) {
        heroData.chips -= 200;
        gameState.coins -= 2500;
        heroData.level++;
        saveProgress();
        renderUpgradeList();
        alert(`¬°${name} subi√≥ al nivel ${heroData.level}!`);
    } else {
        alert("Necesitas 200 fichas y 2500 monedas.");
    }
}

/** * ESTAD√çSTICAS DE H√âROES */
function getHeroStats(name, lvl) {
    if (lvl < 1) lvl = 1;
    if (lvl > 10) lvl = 10;
    
    let stats = { cost: 0, dmg: 0, hp: 0, cooldown: 0, special: null };
    if (name === "Soaphie") stats.cost = (lvl <= 3) ? 4 : (lvl <= 6 ? 3 : (lvl <= 8 ? 2 : 1));
    else if (name === "Reactor") stats.cost = (lvl <= 6) ? 2 : 1;
    else if (name === "Doblap") stats.cost = [0, 8,8,7,7,6,6,5,5,4,4][lvl];
    else if (name === "Stap") stats.cost = (lvl <= 3) ? 7 : (lvl <= 6 ? 6 : (lvl <= 8 ? 5 : 4));
    else if (name === "Squap") stats.cost = [0, 16,15,14,13,12,12,11,10,9,8][lvl];
    else if (name === "Spenge") stats.cost = [0, 16,15,14,13,12,12,11,10,9,8][lvl];
    else if (name === "ReactorDoble") stats.cost = (lvl <= 4) ? 4 : 3;
    else if (name === "Ballge") stats.cost = [0, 9,9,8,8,7,7,6,6,5,5][lvl];
    else if (name === "Ikelo") stats.cost = (lvl <= 3) ? 11 : (lvl <= 6 ? 10 : (lvl <= 8 ? 9 : 8));
    else if (name === "Fuernando") stats.cost = [0, 16,15,14,13,12,12,11,10,9,8][lvl];
    else if (name === "Pennfume") stats.cost = (lvl <= 6) ? 3 : 2;
    else if (name === "Ninjap") stats.cost = [0, 10,10,9,9,8,8,7,7,6,6][lvl];
    else if (name === "RunnerSoaphie") stats.cost = (lvl <= 3) ? 6 : (lvl <= 6 ? 5 : 4);
    else if (name === "Pastual") stats.cost = [0, 8,8,7,7,6,6,5,5,4,4][lvl];
    else if (name === "Lypia") stats.cost = [0, 8,8,7,7,6,6,5,5,4,4][lvl];
    else if (name === "Elenectrica") stats.cost = [0, 10,10,9,9,8,8,7,7,6,5][lvl];
    else if (name === "Vampierce") stats.cost = [0, 14,14,13,13,12,11,10,9,8,7][lvl];
    else if (name === "RunnerNinjap") stats.cost = [0, 32,31,30,28,26,24,22,20,18,16][lvl];
    else if (name === "Knap") stats.cost = [0, 7,7,7,6,6,6,5,5,4,4][lvl];
    else if (name === "Lashra") stats.cost = [0, 10,10,9,9,8,8,7,7,6,5][lvl];
    else if (name === "Roostert") stats.cost = [0, 14,14,13,13,12,11,10,9,8,7][lvl];

    else stats.cost = 5;

    if (name === "Ninjap") {
        const hpTable = [0, 2000, 2500, 3000, 3250, 3500, 4000, 4250, 4500, 4750, 5000];
        stats.hp = hpTable[lvl];
    } else {
        stats.hp = lvl * 100;
    }

    const soapDmg = lvl * 10;
    if (["Soaphie", "Doblap", "Stap", "Squap", "RunnerSoaphie", "Ninjap"].includes(name)) stats.dmg = soapDmg;
    if (name === "Spenge") stats.baseDmg = lvl === 1 ? 20 : (getHeroStats(name, lvl - 1).baseDmg * 1.2);
    else if (name === "Ballge") stats.baseDmg = lvl === 1 ? 100 : (getHeroStats(name, lvl - 1).baseDmg * 1.2);
    if (name === "Ikelo") stats.dmg = 20 * lvl;
    if (name === "Fuernando") stats.dmg = 40 * lvl;
    if (name === "Lypia") {
        const lypiaDmg = [0, 25, 50, 75, 100, 125, 150, 175, 200, 225, 250];
        stats.dmg = lypiaDmg[lvl];
    }
    if (name === "Elenectrica") {
        const elenectricaDmg = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
        stats.dmg = elenectricaDmg[lvl];
    }
    if (name === "Pennfume" || name === "Pastual") stats.dmg = 0;
    stats.cooldown = HEROES_INFO[name].type.includes("shooter") ? 120 : 60; 
    if (name === "Stap") stats.cooldown = 120;
    if (name === "Ninjap") stats.cooldown = 120;
    if (name === "Doblap") stats.cooldown = 60;
    if (name === "Squap") stats.cooldown = 30;
    if (name === "RunnerSoaphie") stats.cooldown = 120;
    if (name === "Lypia" || name === "Stap") stats.cooldown = 150;
    if (name === "Elenectrica") stats.cooldown = 120;
    if (name === "Reactor") {
        let secs = 10;
        if (lvl >= 3) secs = 9; if (lvl >= 5) secs = 8;
        if (lvl >= 7) secs = 7; if (lvl >= 9) secs = 6;
        if (lvl === 10) secs = 5;
        stats.cooldown = secs * 60;
        stats.production = 1;
    }
    if (name === "ReactorDoble") {
        let secs = 5;
        if (lvl >= 4) secs = 4; if (lvl >= 7) secs = 3;
        if (lvl >= 9) secs = 2;
        stats.cooldown = secs * 60;
        stats.production = 1;
    }

    if (name === "RunnerSoaphie") {
        if (lvl <= 2) stats.specialRange = 6;
        else if (lvl <= 4) stats.specialRange = 5;
        else if (lvl <= 6) stats.specialRange = 4;
        else if (lvl === 7) stats.specialRange = 3;
        else if (lvl === 8) stats.specialRange = 2;
        else if (lvl === 9) stats.specialRange = 1;
        else stats.specialRange = -1;
    }
    if (name === "Elenectrica") {
        const elenectricaDmg = lvl * 10;
        stats.dmg = elenectricaDmg;
        stats.productionChance = 0.25;
    }
    if (name === "Vampierce") {
        stats.cost = 14; stats.dmg = 0;
    }
    if (name === "Knap") {
        stats.dmg = lvl * 200;
        stats.cooldown = 600; 
    }
    if (name === "Lashra") {
        stats.dmg = lvl * 10;
        stats.explosiveDmg = lvl * 50;
    }
    else if (name === "Roostert") {
        stats.dmg = lvl * 20;
        stats.cooldown = 300;
    }
    else if (name === "RunnerNinjap") {
        stats.hp = [0, 2000, 2500, 3000, 3250, 3500, 4000, 4250, 4500, 4750, 5000][lvl];
        
        stats.dmg = lvl * 40;     // Ataque fuerte (Columnas 1-6)
        stats.weakDmg = lvl * 10; // Ataque d√©bil/secundario (Columnas 7-10)

        // Habilidad especial (Mejora de rango id√©ntica a Runner Soaphie)
        if (lvl <= 2) stats.specialRange = 6;
        else if (lvl <= 4) stats.specialRange = 5;
        else if (lvl <= 6) stats.specialRange = 4;
        else if (lvl === 7) stats.specialRange = 3;
        else if (lvl === 8) stats.specialRange = 2;
        else if (lvl === 9) stats.specialRange = 1;
        else stats.specialRange = -1;
    }
    // Catapultas
    if (name.startsWith("Catapulta")) { stats.cost = 0; stats.hp = 500; }

    return stats;
}

/** * NAVEGACI√ìN ENTRE PANTALLAS */
function openUpgrades() {
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('upgrade-screen').style.display = 'block';
    renderUpgradeList();
}

function renderUpgradeList() {
    const container = document.getElementById('heroes-upgrade-list');
    container.innerHTML = "";
    HERO_NAMES.forEach(name => {
        let hInv = gameState.inventory[name];
        let info = HEROES_INFO[name];
        let card = document.createElement('div');
        card.className = "info-card";
        let statsNow = getHeroStats(name, hInv.level);
        let statsNext = getHeroStats(name, hInv.level + 1);
        let dmgLabel = statsNow.dmg || statsNow.baseDmg || 0;
        let canUpgrade = hInv.level < 10 && hInv.chips >= 200 && gameState.coins >= 2500;
        
        card.innerHTML = `
            <h3>${name} <span style="font-size:12px; color:white">Nvl ${hInv.level}</span></h3>
            <div style="font-size:12px; color:#ccc;">${info.desc}</div>
            <div style="margin:5px 0; font-size:11px;">
              Vida: ${statsNow.hp} <span style="color:lime">${hInv.level<10 ? '‚Üí ' + statsNext.hp : ''}</span><br>
              Da√±o: ${Number(dmgLabel).toFixed(0)} <span style="color:lime">${hInv.level<10 ? '‚Üí ' + Number(statsNext.dmg || statsNext.baseDmg || 0).toFixed(0) : ''}</span><br>
              Coste: ${statsNow.cost} <span style="color:cyan">${hInv.level<10 && statsNext.cost !== statsNow.cost ? '‚Üí ' + statsNext.cost : ''}</span>
            </div>
            <div style="background:#222; padding:5px; border-radius:4px; font-size:11px; display:flex; justify-content:space-between;">
                <span>Fichas: ${hInv.chips}/200</span>
                <span>${hInv.level < 10 ? '2500üí∞' : 'MAX'}</span>
            </div>
            ${hInv.level < 10 ? `<button class="btn upgrade-btn" style="background:${canUpgrade ? '#4caf50' : '#555'}" onclick="upgradeHero('${name}')">Mejorar</button>` : '<button class="btn upgrade-btn" style="background:#gold; color:black; cursor:default">M√ÅXIMO</button>'}
        `;
        container.appendChild(card);
    });
}

function goToMenu() {
    // Si est√°bamos en modo infinito y salimos desde dentro del juego (no gameover), reclamamos recursos
    if (gameState.mode === 'infinite' && gameState.infinite.active && !gameState.gameOver) {
        // En teor√≠a, salir desde dentro de la partida (bot√≥n Volver en pausa o algo as√≠) ser√≠a rendirse.
        // Pero aqu√≠ el "Abandonar" se hace desde el selector de mazo entre rondas, que llama a saveAndExitInfinite.
        // Si se llama a goToMenu directamente en medio de una partida, se considera derrota (gameover = true).
    }
    
    gameState.gameOver = true;
    gameState.mode = 'story';
    document.querySelectorAll('.screen').forEach(screen => screen.style.display = 'none');
    document.getElementById('menu-screen').style.display = 'block';
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('hero-selector').style.display = 'none';
    saveProgress();
    renderLevelGrid();
    updateUpgradesButton();
    updateInfiniteButton();
}

function openEncyclopedia() {
    document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
    document.getElementById('encyclopedia-screen').style.display = 'block';
    showEncyclopediaTab('germs');
}

function showEncyclopediaTab(tab) {
    const container = document.getElementById('pedia-content');
    container.innerHTML = "";
    if (tab === 'germs') {
        Object.keys(ENEMIES_DATA).forEach(k => {
            let e = ENEMIES_DATA[k];
            let d = document.createElement('div');
            d.className = "info-card";
            d.innerHTML = `<h3 style="color:${e.color}">${k}</h3><p>HP: ${e.hp} | Dmg: ${e.damage}</p>`;
            container.appendChild(d);
        });
    } else if (tab === 'heroes') {
        HERO_NAMES.forEach(name => {
            let info = HEROES_INFO[name];
            let stats = getHeroStats(name, 1);
            let dmgValue = stats.dmg || stats.baseDmg || '-';
            let card = document.createElement('div');
            card.className = "info-card";
            card.innerHTML = `
                <h3 style="color:${info.color}">${name}</h3>
                <div style="font-size:13px; color:#ccc; margin:8px 0;">${info.desc}</div>
                <div style="font-size:12px; line-height:1.4;">
                    Tipo: <strong>${info.type}</strong><br>
                    Coste base: <strong>${stats.cost}</strong><br>
                    Vida base: <strong>${stats.hp}</strong><br>
                    Da√±o base: <strong>${Number(dmgValue).toFixed(0)}</strong><br>
                    Recarga: <strong>${info.reload}s</strong>
                </div>
            `;
            container.appendChild(card);
        });
    }
}

function renderLevelGrid() {
    const grid = document.getElementById('level-grid');
    grid.innerHTML = "";
    for (let i = 1; i <= 86; i++) {
        const btn = document.createElement('div');
        const unlocked = i <= gameState.maxLevel;
        btn.className = `lvl-btn ${unlocked ? 'unlocked' : 'locked'}`;
        btn.innerText = i;
        if (unlocked) {
            btn.onclick = () => prepareLevel(i);
            if (gameState.dailyPlayed.includes(i)) {
                let check = document.createElement('div');
                check.className = "daily-check";
                check.innerHTML = "‚úî";
                btn.appendChild(check);
            }
        }
        grid.appendChild(btn);
    }
}

/** * MODO INFINITO */
function startInfiniteMode() {
    gameState.mode = 'infinite';
    
    if (!gameState.infinite.active) {
        // Reset infinite state for new run
        gameState.infinite.active = true;
        gameState.infinite.wave = 1;
        gameState.infinite.pool = ["Reactor", "Soaphie"];
        gameState.infinite.deck = ["Reactor", "Soaphie"];
        gameState.infinite.savedBoard = [];
        gameState.infinite.pendingCoins = 0;
        gameState.infinite.pendingBills = 0;
        prepareInfiniteLevel();
    } else {
        // Continuar carrera existente
        // Vamos directamente al selector de mazo antes de la siguiente ola
        showDeckSelector(null, true); 
    }
}

function prepareInfiniteLevel() {
    const wave = gameState.infinite.wave;
    gameState.level = `‚àû ${wave}`;
    gameState.currentDeck = [...gameState.infinite.deck];
    
    let count = 20 + Math.floor(wave * 2); 
    let rate = Math.max(100, 800 - (wave * 15)); 
    
    let pool = ["Normal"];
    
    if (wave === 2) pool = ["Sangre"];
    else if (wave === 3) pool = ["MasSangre"];
    else if (wave >= 4) {
        pool = ["Normal", "Sangre", "MasSangre"];
        const extraTypes = ["Resortera", "Acuatico", "Fuego", "Hielo", "Succionador", "Teleporter"];
        let typesToAdd = Math.min(extraTypes.length, Math.floor((wave - 3) / 2) + 1);
        for(let i=0; i<typesToAdd; i++) {
            let t = extraTypes[Math.floor(Math.random()*extraTypes.length)];
            if(!pool.includes(t)) pool.push(t);
        }
    }
    
    if (wave >= 10) pool.push("Super");
    if (wave >= 20) pool.push("SuperRojo");

    const levelData = {
        count: count,
        rate: rate,
        pool: pool
    };
    
    startLevel(levelData);
}

function claimInfiniteRewards() {
    if (gameState.infinite.pendingCoins > 0 || gameState.infinite.pendingBills > 0) {
        gameState.coins += gameState.infinite.pendingCoins;
        gameState.bills += gameState.infinite.pendingBills;
        alert(`Recogiste: ${gameState.infinite.pendingCoins} monedas y ${gameState.infinite.pendingBills} billetes.`);
        gameState.infinite.pendingCoins = 0;
        gameState.infinite.pendingBills = 0;
    }
}

// SERIALIZACI√ìN DEL TABLERO
function saveInfiniteBoard() {
    gameState.infinite.savedBoard = heroes.filter(h => h.hp > 0).map(h => ({
        col: h.col,
        row: h.y, // Usamos 'y' como fila en el objeto Hero original
        name: h.name,
        hp: h.hp
    }));
    // Tambi√©n guardamos los rayos
    gameState.infinite.savedRays = gameState.rayos;
}

function loadInfiniteBoard() {
    if (gameState.infinite.savedBoard && gameState.infinite.savedBoard.length > 0) {
        heroes = gameState.infinite.savedBoard.map(d => {
            let h = new Hero(d.col, d.row, d.name);
            h.hp = d.hp;
            return h;
        });
    }
    // Restaurar rayos si existen, si no, usar por defecto
    if (gameState.infinite.savedRays !== undefined) {
        gameState.rayos = gameState.infinite.savedRays;
    }
}

function showDraftScreen() {
    document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
    document.getElementById('draft-screen').style.display = 'block';
    document.getElementById('hero-selector').style.display = 'none';
    
    const container = document.getElementById('draft-pool');
    container.innerHTML = "";
    
    const unlocked = gameState.availableHeroes;
    for(let i=0; i<3; i++) {
        let hero = unlocked[Math.floor(Math.random() * unlocked.length)];
        let lvl = gameState.inventory[hero].level;
        let stats = getHeroStats(hero, lvl);
        
        let btn = createCardHTML(hero, stats.cost, lvl);
        btn.onclick = () => selectDraftHero(hero);
        container.appendChild(btn);
    }
}

function selectDraftHero(heroName) {
    // A√±adir al pool de disponibles en infinito (no al mazo activo directamente)
    if (!gameState.infinite.pool.includes(heroName)) {
        gameState.infinite.pool.push(heroName);
    }
    // Si ya lo tiene, quiz√°s darle un bono de curaci√≥n o algo, pero por ahora solo lo desbloquea para usar.
    
    gameState.infinite.wave++;
    saveProgress();
    
    // Despu√©s del draft, vamos al selector de mazo para prepararnos para la sgte ronda o salir
    showDeckSelector(null, true);
}

function saveAndExitInfinite() {
    claimInfiniteRewards(); // Reclamar lo ganado hasta ahora
    saveProgress();
    goToMenu();
}

/** * PREPARACI√ìN DEL NIVEL Y MAZO (HISTORIA) */
function prepareLevel(lvlNum) {
    gameState.mode = 'story';
    gameState.level = lvlNum;
    checkUnlocks(lvlNum);
    const lvlData = LEVELS[lvlNum - 1];
    if (lvlData.fixedDeck) {
        gameState.currentDeck = [...lvlData.fixedDeck];
        startLevel(lvlData);
    } else {
        showDeckSelector(lvlNum, false);
    }
}

function showDeckSelector(lvlNum, isInfinite) {
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('draft-screen').style.display = 'none';
    document.getElementById('deck-screen').style.display = 'block';
    
    // Configurar botones
    const btnConfirm = document.getElementById('deck-confirm-btn');
    const btnSaveExit = document.getElementById('deck-save-exit-btn');
    const btnBack = document.getElementById('deck-back-btn');
    
    const h2 = document.querySelector('#deck-screen h2');

    if (isInfinite) {
        btnConfirm.onclick = () => confirmInfiniteDeck();
        btnSaveExit.style.display = 'inline-block';
        btnBack.style.display = 'none'; 
        h2.innerHTML = `Ola ${gameState.infinite.wave} <span style="font-size:0.7em">(<span id="deck-count">0/6</span>)</span>`;
    } else {
        btnConfirm.onclick = () => confirmDeck();
        btnSaveExit.style.display = 'none';
        btnBack.style.display = 'inline-block';
        h2.innerHTML = `Elige tu Equipo <span style="font-size:0.7em">(<span id="deck-count">0/${gameState.deckLimit7 ? 7 : 6}</span>)</span>`;
    }

    const poolContainer = document.getElementById('deck-pool');
    poolContainer.innerHTML = "";
    
    let sourcePool = isInfinite ? gameState.infinite.pool : gameState.availableHeroes;

    if (!isInfinite && lvlNum === 61) {
        sourcePool = sourcePool.filter(hero => 
            hero !== "Reactor" && 
            hero !== "ReactorDoble" && 
            hero !== "Elenectrica"
        );
    }
    
    sourcePool.forEach(hero => {
        let lvl = gameState.inventory[hero].level;
        let stats = getHeroStats(hero, lvl);
        let btn = createCardHTML(hero, stats.cost, lvl);
        btn.onclick = () => toggleDeckHero(hero);
        poolContainer.appendChild(btn);
    });
    
    // Pre-seleccionar el mazo actual
    tempDeck = isInfinite ? [...gameState.infinite.deck] : [];
    renderDeckSelected();
    
    // Marcar visualmente
    updateDeckVisuals();
}

let tempDeck = [];
function toggleDeckHero(heroName) {
    const idx = tempDeck.indexOf(heroName);
    const maxDeck = gameState.deckLimit7 ? 7 : 6;
    if (idx > -1) {
        tempDeck.splice(idx, 1);
    } else {
        if (tempDeck.length < maxDeck) tempDeck.push(heroName);
    }
    renderDeckSelected();
    updateDeckVisuals();
}

function updateDeckVisuals() {
    Array.from(document.getElementById('deck-pool').children).forEach(btn => {
        // Extraer nombre del innerText con cuidado
        let name = btn.innerText.split('Lvl')[0].trim();
        // Limpiar el coste si existe
        name = name.replace(/[0-9]+$/, '').trim(); 
        
        if(tempDeck.includes(name)) btn.classList.add('picked');
        else btn.classList.remove('picked');
    });
}

function renderDeckSelected() {
    const container = document.getElementById('deck-selected');
    container.innerHTML = "";
    const maxDeck = gameState.deckLimit7 ? 7 : 6;
    const counter = document.getElementById('deck-count');
    if(counter) counter.innerText = `${tempDeck.length}/${maxDeck}`;
    
    tempDeck.forEach(hero => {
        let lvl = gameState.inventory[hero].level;
        let stats = getHeroStats(hero, lvl);
        let btn = createCardHTML(hero, stats.cost, lvl);
        btn.onclick = () => toggleDeckHero(hero);
        container.appendChild(btn);
    });
}

function confirmDeck() {
    if (tempDeck.length === 0) return alert("Elige al menos un h√©roe.");
    gameState.currentDeck = [...tempDeck];
    document.getElementById('deck-screen').style.display = 'none';
    startLevel(LEVELS[gameState.level - 1]);
}

function confirmInfiniteDeck() {
    if (tempDeck.length === 0) return alert("Elige al menos un h√©roe.");
    gameState.infinite.deck = [...tempDeck];
    saveProgress(); // Guardar selecci√≥n de mazo
    document.getElementById('deck-screen').style.display = 'none';
    prepareInfiniteLevel();
}

function continueGame() { prepareLevel(Math.min(gameState.maxLevel, 86)); }

/** * INICIO DE NIVEL */
function startLevel(lvlData) {
    updateBackground(gameState.level);
    gameState.gameOver = false;
    gameState.enemiesToSpawn = lvlData.count;
    gameState.totalEnemies = lvlData.count;
    
    gameState.currentLevelData = lvlData; 
    
    gameState.spawnedCount = 0;
    gameState.spawnTimer = 0;
    
    gameState.currentSpawnInterval = 1800;
    if (gameState.mode === 'infinite') gameState.currentSpawnInterval = Math.max(60, 1800 - (gameState.infinite.wave * 100));

    const targetInterval = 900;
    const enemiesToAccelerate = 12;
    gameState.intervalDecrement = (1800 - targetInterval) / enemiesToAccelerate;

    gameState.levelFrame = 0;
    gameState.bossStartedSpawning = false;

    if (lvlData.startRays) {
        gameState.rayos = lvlData.startRays;
    } else {
         if (typeof gameState.level === 'number' && [10,18,36,54,86].includes(gameState.level)) gameState.rayos = 100;
         else gameState.rayos = 4;
    }
    
    gameState.timerRayo = 20;
    gameState.producedRaysCount = 0;
    gameState.heroesLostCount = 0;
    gameState.superSpawned = 0;
    gameState.raysSpent = 0;
    gameState.killObjCount = 0;
    gameState.killObjFailed = false;

    gameState.heroCurrentReloads = {};
    heroes = []; enemies = [];
    projectiles = []; popups = [];
    
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('draft-screen').style.display = 'none';
    
    // RESTAURAR TABLERO INFINITO O CONFIGURAR NIVEL HISTORIA
    if (gameState.mode === 'infinite') {
        // Si es ola > 1, cargamos el tablero
        if (gameState.infinite.wave > 1) {
            loadInfiniteBoard();
        }
        // Nota: en ola 1 empezamos vac√≠os
    } 
    else if (gameState.mode === 'story') {
        if (gameState.level === 10) setupBoss1();
        if (gameState.level === 18) setupBoss2();
        if (gameState.level === 36) setupBoss3();
        if (gameState.level === 54) setupBoss4();
        if (gameState.level === 86) setupBoss5();
        if (lvlData.startSetup === "20Soaphies") setupLevel46();
        if (lvlData.startSetup === "col0Reactors") setupLevel47();
        if (lvlData.startSetup === "PastualDefense") setupLevel50();
        if (lvlData.startSetup === "level41") setupLevel41();
        if (lvlData.startSetup === "level42") setupLevel42();
        if (lvlData.startSetup === "level45") setupLevel45();
        if (lvlData.startSetup === "level52") setupLevel52();
        if (lvlData.startSetup === "level57") setupLevel57();
        if (lvlData.startSetup === "level58") setupLevel58();
        if (lvlData.startSetup === "level60") setupLevel60();
        if (lvlData.startSetup === "level62") setupLevel62();
        if (lvlData.startSetup === "level63") setupLevel63();
        if (lvlData.startSetup === "level64") setupLevel64();
        if (lvlData.startSetup === "level66") setupLevel66();
        if (lvlData.startSetup === "level70") setupLevel70();
        if (lvlData.startSetup === "level72") setupLevel72();
        if (lvlData.startSetup === "level73") setupLevel73();
        if (lvlData.startSetup === "level74") setupLevel74();
        if (lvlData.startSetup === "level83") setupLevel83();
    }
    
    createHeroButtons();
    updateUI();
    resizeGame();
    requestAnimationFrame(gameLoop);
}

function createStaticCatapult(row, col, type) {
    let cat = new Hero(col, row, type);
    heroes.push(cat);
    
    // Bloqueamos las celdas en el sistema de rejilla del juego
    if(gameState.grid && gameState.grid[row]) {
        gameState.grid[row][col] = true;
        // La catapulta ocupa dos casillas
        if (col + 1 < 10) gameState.grid[row][col + 1] = true;
    }
}

function setupBoss1() { gameState.bossHP = 20000; gameState.machines = Array.from({length:5}, (_, i) => ({ row: i, hp: 200, maxHp: 200, spawnTimer: 0, respawnTimer: 0 })); }
function setupBoss2() { gameState.bossHP = 30000; gameState.machines = Array.from({length:5}, (_, i) => ({ row: i, hp: 500, maxHp: 500, spawnTimer: 0, respawnTimer: 0 })); }
function setupBoss3() { gameState.bossHP = 30000; gameState.machines = Array.from({length:5}, (_, i) => ({ row: i, hp: 1000, maxHp: 1000, spawnTimer: 0, respawnTimer: 0 })); }
function setupBoss4() { gameState.bossHP = 40000; gameState.machines = Array.from({length:5}, (_, i) => ({ row: i, hp: 1500, maxHp: 1500, spawnTimer: 0, respawnTimer: 0 })); }
function setupBoss5() { gameState.bossHP = 40000; gameState.machines = Array.from({length:5}, (_, i) => ({ row: i, hp: 1500, maxHp: 1500, spawnTimer: 0, respawnTimer: 0 })); }

function setupLevel46() { for(let r=0; r<5; r++) for(let c=0; c<4; c++) heroes.push(new Hero(c, r, "Soaphie")); }
function setupLevel47() { for(let r=0; r<5; r++) { heroes.push(new Hero(0, r, "Reactor")); heroes.push(new Hero(1, r, "Reactor")); } }
function setupLevel50() { [2,4,6,8].forEach(c => { for(let r=0; r<5; r++) heroes.push(new Hero(c, r, "Pastual")); }); for(let r=0; r<5; r++) heroes.push(new Hero(0, r, "ReactorDoble")); }

function setupLevel41() { for(let r=0; r<5; r++) { let h = new Hero(5, r, "Reactor"); h.isProtected = true; heroes.push(h); } }
function setupLevel42() { for(let r=0; r<5; r++) { let h = new Hero(0, r, "Squap"); h.isProtected = true; heroes.push(h); } }
function setupLevel45() { 
    let h1 = new Hero(1, 1, "RunnerSoaphie"); h1.isProtected = true; heroes.push(h1);
    let h2 = new Hero(1, 3, "RunnerSoaphie"); h2.isProtected = true; heroes.push(h2);
    let h3 = new Hero(6, 1, "RunnerSoaphie"); h3.isProtected = true; heroes.push(h3);
    let h4 = new Hero(6, 3, "RunnerSoaphie"); h4.isProtected = true; heroes.push(h4);
}
function setupLevel52() { for(let r=0; r<5; r++) { let h = new Hero(0, r, "Lypia"); h.isProtected = true; heroes.push(h); } }
function setupLevel57() {
    // Una columna de Elen√©ctricas y una columna de Ballges
    for(let r=0; r<5; r++) {
        heroes.push(new Hero(0, r, "Elenectrica"));
        heroes.push(new Hero(1, r, "Ballge"));
    }
}
function setupLevel58() {
    for(let r=0; r<5; r++) {
        heroes.push(new Hero(0, r, "Reactor")); heroes.push(new Hero(1, r, "Reactor"));
        heroes.push(new Hero(2, r, "Soaphie")); heroes.push(new Hero(3, r, "Soaphie"));
        heroes.push(new Hero(4, r, "Soaphie")); heroes.push(new Hero(5, r, "Soaphie"));
    }
}
function setupLevel60() {
    heroes.push(new Hero(0, 0, "ReactorDoble")); heroes.push(new Hero(1, 0, "ReactorDoble"));
    heroes.push(new Hero(0, 1, "ReactorDoble")); heroes.push(new Hero(1, 1, "ReactorDoble"));
    heroes.push(new Hero(0, 2, "ReactorDoble")); heroes.push(new Hero(1, 2, "ReactorDoble"));
    heroes.push(new Hero(0, 3, "ReactorDoble")); heroes.push(new Hero(1, 3, "ReactorDoble"));
    heroes.push(new Hero(0, 4, "ReactorDoble")); heroes.push(new Hero(1, 4, "ReactorDoble"));
    heroes.push(new Hero(7, 0, "Vampierce")); heroes.push(new Hero(7, 1, "Vampierce"));
    heroes.push(new Hero(7, 2, "Vampierce")); heroes.push(new Hero(7, 3, "Vampierce"));
    heroes.push(new Hero(7, 4, "Vampierce"));
}
function setupLevel62() {
    // 1x1, 1x2 -> col 0, row 0 y 1. Simulaci√≥n ocupando 2 espacios visuales
    createStaticCatapult(0, 0, "CatapultaEspuma");
    createStaticCatapult(2, 0, "CatapultaEspuma");
    createStaticCatapult(4, 0, "CatapultaEspuma");
}
function setupLevel63() {
    createStaticCatapult(1, 0, "CatapultaHielo");
    createStaticCatapult(3, 0, "CatapultaHielo");
}
function setupLevel64() {
    createStaticCatapult(0, 0, "CatapultaEspuma");
    createStaticCatapult(1, 0, "CatapultaHielo");
    createStaticCatapult(2, 0, "CatapultaEspuma");
    createStaticCatapult(3, 0, "CatapultaHielo");
    createStaticCatapult(4, 0, "CatapultaEspuma");
}
function setupLevel66() {
    for(let r=0; r<5; r++) {
        heroes.push(new Hero(0, r, "ReactorDoble")); heroes.push(new Hero(1, r, "ReactorDoble"));
        heroes.push(new Hero(2, r, "ReactorDoble")); heroes.push(new Hero(6, r, "Stap"));
        heroes.push(new Hero(7, r, "Stap")); heroes.push(new Hero(8, r, "Stap"));
    }
}
function setupLevel70() {
    for(let r=0; r<5; r++) {
        heroes.push(new Hero(0, r, "Pennfume")); heroes.push(new Hero(1, r, "Lypia"));
        heroes.push(new Hero(2, r, "Lypia")); heroes.push(new Hero(3, r, "Lypia"));
        heroes.push(new Hero(4, r, "Lypia"));
    }
}
function setupLevel72() {
    // Posiciones en la grilla (Fila, Columna)
    let pos = [
        {r:0,c:6}, 
        {r:1,c:4}, {r:1,c:5}, {r:1,c:6}, {r:1,c:7}, {r:1,c:8}, 
        {r:2,c:6}, 
        {r:3,c:5}, {r:3,c:6}, {r:3,c:7}, 
        {r:4,c:4}, {r:4,c:6}, {r:4,c:8}
    ];

    pos.forEach(p => {
        let machine = new Enemy("Normal"); // Usamos "Normal" como base
        machine.isGrowMachine = true;      // Bandera especial
        machine.hp = 200;                  // Salud requerida
        machine.maxHp = 200;
        
        // Posici√≥n exacta en la grilla
        machine.x = p.c * 80 + 10; 
        machine.y = p.r * 80 + 10;
        machine.row = p.r;
        machine.col = p.c; // Guardamos columna para bloquear construcci√≥n
        
        machine.spawnTimer = 0; // Inicia en 0 para esperar los primeros 30s
        
        enemies.push(machine);
    });
}

function setupLevel73() {
    // Posiciones en la grilla (Fila, Columna)
    let pos = [
        {r:0,c:9}, {r:1,c:9}, {r:2,c:9}, {r:3,c:9}, {r:4,c:9},
    ];

    pos.forEach(p => {
        let machine = new Enemy("Normal"); // Usamos "Normal" como base
        machine.isGrowMachine = true;      // Bandera especial
        machine.hp = 200;                  // Salud requerida
        machine.maxHp = 200;
        
        // Posici√≥n exacta en la grilla
        machine.x = p.c * 80 + 10; 
        machine.y = p.r * 80 + 10;
        machine.row = p.r;
        machine.col = p.c; // Guardamos columna para bloquear construcci√≥n
        
        machine.spawnTimer = 0; // Inicia en 0 para esperar los primeros 30s
        
        enemies.push(machine);
    });
    createStaticCatapult(1, 0, "CatapultaEspuma");
    createStaticCatapult(3, 0, "CatapultaEspuma");
}
function setupLevel74() {
    let h1 = new Hero(2, 1, "Lashra"); h1.isProtected = true; heroes.push(h1);
    let h2 = new Hero(2, 3, "Lypia"); h2.isProtected = true; heroes.push(h2);
}
function setupLevel83() {
    for(let r=0; r<5; r++) {
        heroes.push(new Hero(0, r, "ReactorDoble"));
        heroes.push(new Hero(1, r, "Squap"));
        heroes.push(new Hero(3, r, "Squap"));
    }
}

function checkUnlocks(lvl) {
    let all = ["Soaphie", "Reactor"];
    if (gameState.maxLevel >= 2) all.push("Doblap");
    if (gameState.maxLevel >= 4) all.push("Stap");
    if (gameState.maxLevel >= 5) all.push("Squap");
    if (gameState.maxLevel >= 11) all.push("Spenge");
    if (gameState.maxLevel >= 14) all.push("ReactorDoble");
    if (gameState.maxLevel >= 16) all.push("Ballge");
    if (gameState.maxLevel >= 19) all.push("Ikelo");
    if (gameState.maxLevel >= 24) all.push("Fuernando");
    if (gameState.maxLevel >= 29) all.push("Pennfume");
    if (gameState.maxLevel >= 37) all.push("Ninjap");
    if (gameState.maxLevel >= 43) all.push("RunnerSoaphie");
    if (gameState.maxLevel >= 47) all.push("Pastual");
    if (gameState.maxLevel >= 50) all.push("Lypia");
    if (gameState.maxLevel >= 55) all.push("Elenectrica");
    if (gameState.maxLevel >= 58) all.push("Vampierce");
    if (gameState.maxLevel >= 64) all.push("RunnerNinjap");
    if (gameState.maxLevel >= 67) all.push("Knap");
    if (gameState.maxLevel >= 73) all.push("Lashra");
    if (gameState.maxLevel >= 80) all.push("Roostert");
    gameState.availableHeroes = all;
    
    gameState.hasTrash = (lvl >= 6);
    gameState.trashUpgrade = (lvl >= 22);
    gameState.trashUpgrade2 = (gameState.maxLevel >= 45);
    gameState.deckLimit7 = (gameState.maxLevel >= 38);
    
    if (gameState.mode === 'infinite') {
        gameState.hasTrash = true;
        gameState.trashUpgrade = true;
    }
}

function createCardHTML(name, cost, level) {
    let hInfo = HEROES_INFO[name];
    
    // Obtenemos la URL del h√©roe (ya definida en tu c√≥digo como spriteUrls)
    let imgUrl = spriteUrls[name] || ""; 

    let btn = document.createElement('div');
    btn.className = 'hero-card';
    
    // Aqu√≠ est√° el truco: Ponemos la imagen como background-image del icono
    // y a√±adimos un degradado suave para que se lea el texto si la imagen es clara
    let iconHtml = `
        <div class="hero-icon" style="
            background-color: ${hInfo.color}; 
            background-image: url('${imgUrl}'); 
            background-size: cover; 
            background-position: center;
        "></div>
    `;

    btn.innerHTML = `${iconHtml}
                     <div style="z-index:2; text-shadow: 1px 1px 2px black;">${name}</div>
                     <span style="font-size:9px; color:#ddd; z-index:2">Lvl ${level}</span>`;
    
    if(cost !== undefined) {
        btn.innerHTML += `<span style="color:cyan; font-weight:bold; font-size:11px; z-index:2; margin-top:2px;">${cost}‚ö°</span>`;
    }
    
    return btn;
}

function createHeroButtons() {
    const container = document.getElementById('hero-selector');
    container.style.display = 'flex';
    container.innerHTML = "";
    gameState.currentDeck.forEach(name => {
        let lvl = gameState.inventory[name].level;
        let stats = getHeroStats(name, lvl);
        let btn = createCardHTML(name, stats.cost, lvl);
        let cdOverlay = document.createElement('div');
        cdOverlay.className = "cooldown-overlay";
        cdOverlay.id = `cd-${name}`;
        cdOverlay.innerText = "5";
        btn.appendChild(cdOverlay);
        
        btn.onclick = () => { gameState.selectedHero = name; gameState.isTrashing = false; highlight(btn); };
        container.appendChild(btn);
    });
    if (gameState.hasTrash) {
        let btn = document.createElement('div');
        btn.className = 'hero-card trash-btn';
        btn.innerHTML = '<div class="hero-icon" style="background:#000; border-color:red">üóë</div>Quitar';
        btn.onclick = () => { gameState.isTrashing = true; gameState.selectedHero = null; highlight(btn); };
        container.appendChild(btn);
    }
}

function updateHeroCooldowns() {
    const now = Date.now();
    gameState.currentDeck.forEach(name => {
        const el = document.getElementById(`cd-${name}`);
        if(el) {
            const end = gameState.heroCurrentReloads[name] || 0;
            if (end > now) {
                const remaining = Math.ceil((end - now) / 1000);
                el.style.display = "flex";
                el.innerText = remaining;
            } else {
                el.style.display = "none";
            }
        }
    });
}

function highlight(btn) {
    document.querySelectorAll('.hero-card').forEach(c => c.classList.remove('selected'));
    btn.classList.add('selected');
}

function enemyDies(e) {
    // 1. Ejecutar SOLAMENTE el bot√≠n de monedas/billetes
    if (e.calculateDrop) e.calculateDrop();

    // 2. L√≥gica de liberaci√≥n de la Versi√≥n 1.2.1 (Vampiro)
    if (e.type === "Vampiro" || e.type === "Controlador") {
        heroes.forEach(h => {
            if (h.isTraitor) {
                h.isTraitor = false;
                h.traitorTimer = 0;
                createPopup(h.col * 80, h.row * 80, "¬°LIBRE!", "lime");
            }
        });
    }

    // 3. Quitar al enemigo de la lista
    enemies = enemies.filter(enemy => enemy !== e);
    gameState.enemiesKilled = (gameState.enemiesKilled || 0) + 1;
    
    // NOTA: Hemos borrado la l√≠nea "gameState.rayos += reward;"
}

function createExplosionArea(centerX, centerY, dmg, isTraitor) {
    let targets = isTraitor ? heroes : enemies;
    let centerRow = Math.floor(centerY / 80);

    targets.forEach(t => {
        let tRow = (t instanceof Enemy) ? t.row : t.y;
        let tX = (t instanceof Enemy) ? t.x + 30 : t.col * 80 + 40;

        // Comprueba si est√° en la fila actual, arriba o abajo, y cerca horizontalmente
        if (Math.abs(tRow - centerRow) <= 1 && Math.abs(tX - centerX) < 120) {
            t.hp -= dmg;
            if (t.hp <= 0) {
                if (t instanceof Enemy) enemyDies(t);
                else heroDies(t);
            }
        }
    });
}

/** * CLASES DEL JUEGO */
class Hero {
    constructor(col, row, name) {
        this.col = col;
        this.y = row; // CORRECCI√ìN: Asignamos 'y' para que la colocaci√≥n funcione
        this.row = row; // Mantenemos 'row' por compatibilidad
        this.name = name;
        
        // 1. Manejo de Catapultas
        if (name.includes("Catapulta")) {
            this.level = 1;
            this.hp = 500;
            this.maxHp = 500;
            this.stats = { hp: 500, range: 0 }; 
            this.data = HEROES_INFO[name] || { color: "#fff" };
            this.shoot = function() { }; 
        } else {
            // 2. Manejo de H√©roes Normales
            if (gameState.inventory && gameState.inventory[name]) {
                this.level = gameState.inventory[name].level;
                this.stats = getHeroStats(name, this.level);
            } else {
                this.level = 1;
                this.stats = { hp: 100, range: 400 };
            }
            this.data = HEROES_INFO[name];
            this.hp = this.stats.hp;
            this.maxHp = this.stats.hp;
        }

        // Propiedades de estado
        this.timer = 0;
        this.realX = col * 80 + 10;
        this.realY = row * 80 + 10;
        this.isRolling = false; // Estado para Catapulta y Ballge
        this.lastAttackTime = Date.now();
        this.frozenTimer = 0;
        
        // F√≠sicas Ballge
        this.ballState = 'idle';
        this.ballVx = 0;
        this.ballVy = 0;
        this.ballHitSet = new Set();
    }

    update() {
        if (this.carriedHero) {
            this.carriedHero.update();
        }
        // --- L√ìGICA ESPEC√çFICA DE CATAPULTAS ---
        if (this.name.includes("Catapulta")) {
            // A. Fase Est√°tica: Disparar
            if (!this.isRolling) {
                this.timer++;
                // Disparo cada 2 segundos (120 frames)
                if (this.timer >= 120) {
                    let pType = this.name.includes("Hielo") ? "ice_bomb" : "foam_bomb";
                    // Creamos un proyectil real para evitar errores de draw()
                    let p = new Projectile(this.realX + 60, this.realY + 30, 20, 5, 0, false, pType);
                    projectiles.push(p);
                    this.timer = 0;
                }

                // B. Detectar colisi√≥n para activar modo rodar
                for (let en of enemies) {
                    // Si un enemigo est√° en la misma fila y toca la catapulta
                    if (en.row === this.y && en.x < this.realX + 80 && en.x > this.realX - 20) {
                        this.isRolling = true;
                        createPopup(this.realX, this.realY, "¬°RODANDO!", "orange");
                        break; 
                    }
                }
            } 
            // C. Fase Rodando (Atropellar)
            else {
                this.realX += 8; // Velocidad de rodada
                
                // Da√±ar enemigos al paso
                enemies.forEach(en => {
                    if (en.row === this.y && Math.abs(en.x - this.realX) < 60) {
                        en.takeDamage(9999); // Instakill al enemigo
                        createPopup(en.x, en.y, "¬°SPLASH!", "white");
                    }
                });

                // Eliminar catapulta si sale de la pantalla
                if (this.realX > 850) {
                    this.hp = 0; // Se elimina sola
                }
            }
            return; // Termina aqu√≠ la l√≥gica de catapulta
        }

        // --- L√ìGICA RESTO DE H√âROES ---
        
        if (this.name === "Ballge" && this.ballState !== 'idle') {
            this.updateBallPhysics();
            return;
        }

        // Temporizador de traici√≥n
        if (this.isTraitor) {
            this.traitorTimer--;
            if (this.traitorTimer <= 0) {
                this.isTraitor = false;
                createPopup(this.col * 80 + 40, this.y * 80 + 40, "¬°Libre!", "lime");
            }
        }

        // L√≥gica Vampierce (Purificaci√≥n)
        if (this.name === "Vampierce") {
            enemies.forEach(e => {
                if ((e.type === "Sangre" || e.type === "MasSangre") && 
                    Math.hypot(e.x - (this.col * 80 + 40), (e.y + 40) - (this.y * 80 + 40)) < 200) {
                    e.type = "Normal";
                    e.data = ENEMIES_DATA["Normal"];
                    e.color = e.data.color;
                    createPopup(e.x, e.y, "Sin armadura de sangre!", "pink");
                }
            });
        }

        // Cooldown y Disparo
        let cooldownMult = (this.frozenTimer > 0) ? 0.5 : 1;
        if (this.frozenTimer > 0) this.frozenTimer--;

        if (this.timer < this.stats.cooldown) {
            this.timer += 1 * cooldownMult;
        } else {
            this.timer = 0;
            
            // Direcci√≥n del disparo
            let dirX = this.isTraitor ? -1 : 1;
            const cx = this.col * 80 + 40;
            const cy = this.y * 80 + 40;

            if (["Spenge", "Ballge", "Pastual"].includes(this.name)) return;

            if (this.data.type === "producer") produceRay(cx, cy);
            else if (this.name === "Elenectrica") {
                let p = new Projectile(cx + (20 * dirX), cy, 10, 6 * dirX, 0, true, "electric", this.isTraitor);
                p.generateEnergy = !this.isTraitor;
                projectiles.push(p);
            }
            else if (this.name === "Knap") {
                let targets = this.isTraitor ? heroes : enemies;
                targets.forEach(t => {
                    let tx = (t instanceof Enemy) ? t.x : t.col * 80;
                    let targetRow = (t instanceof Enemy) ? t.row : t.y;
                    if (t !== this && targetRow === this.y && Math.abs(tx - cx) < 100) {
                        if (this.isTraitor && t.isTraitor) return;
                        t.hp -= 200;
                        if (t instanceof Enemy) t.x += (100 * dirX);
                        if (t.hp <= 0) (t instanceof Enemy) ? enemyDies(t) : heroDies(t);
                        createPopup(cx, cy, "¬°PLAF!");
                    }
                });
            }
            else if (this.data.type === "8-way") {
                const angles = [{vx:5,vy:0}, {vx:-5,vy:0},{vx:0,vy:5},{vx:0,vy:-5},{vx:4,vy:4}, {vx:-4,vy:4},{vx:4,vy:-4},{vx:-4,vy:-4}];
                // Nota: pasamos this.isTraitor al final para que si est√° controlado ataque a aliados
                angles.forEach(a => projectiles.push(new Projectile(cx, cy, this.stats.dmg, a.vx, a.vy, false, "normal", this.isTraitor)));
            }
            else if (this.data.type.startsWith("shooter") || this.name === "Lypia" || this.name === "Roostert" || this.name === "Lashra") {
                let pType = "normal";
                let pIsPiercing = false
                if (this.data.type === "shooter_ice") pType = "ice";
                if (this.data.type === "shooter_fire") pType = "fire";
                if (this.data.type === "shooter_slow") pType = "perfume";
                if (this.name === "Lypia") { pType = "laser"; pIsPiercing = true; } // Lypia ya era perforante
                if (this.name === "Roostert") pType = "roostert_blade";
                if (this.name === "Lashra") {
                    pType = "explosive_spike";
                    pIsPiercing = true; // ¬°Ahora es perforante!
                }
                if (this.name === "Roostert") { 
                    pType = "roostert_blade"; 
                    pIsPiercing = true; // La cuchilla es perforante por defecto
                }
                projectiles.push(new Projectile(cx, cy, this.stats.dmg, 6 * dirX, 0, (pIsPiercing || pType === "perfume"), pType, this.isTraitor));
            }

            if (this.timer < this.stats.cooldown) {
                this.timer++;
            } else if (this.name !== "Ballge") { 
                this.shoot();
                this.timer = 0;
            }
            // En el m√©todo update() de la clase Hero, dentro del bloque de disparo:
            if (this.name === "RunnerNinjap") {
                // Definir direcciones
                // Cruz (+)
                const dirsCross = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                // Equis (X)
                const dirsX = [{x:-1, y:-1}, {x:1, y:-1}, {x:-1, y:1}, {x:1, y:1}];
                
                // Determinar modo actual (iniciado en 'cross' por defecto)
                if (!this.ninjaMode) this.ninjaMode = 'cross';
                const isCrossStrong = (this.ninjaMode === 'cross');

                const dmgStrong = 40;
                const dmgWeak = 10;
                const speed = 6;

                // COLUMNAS 1-6 (Indices 0 a 5): Comportamiento Ninjap Cl√°sico
                if (this.col < 6) {
                    let activeDirs = isCrossStrong ? dirsCross : dirsX;
                    activeDirs.forEach(d => {
                        projectiles.push(new Projectile(cx, cy, dmgStrong, d.x * speed, d.y * speed, false, "normal", this.isTraitor));
                    });
                } 
                // COLUMNAS 7-10 (Indices 6 a 9): Disparo en 8 direcciones con da√±o variable
                else {
                    // Si el modo es Cruz (+): Cruz hace 40, X hace 10
                    // Si el modo es Equis (X): X hace 40, Cruz hace 10
                    let dmgCross = isCrossStrong ? dmgStrong : dmgWeak;
                    let dmgX = isCrossStrong ? dmgWeak : dmgStrong;

                    dirsCross.forEach(d => {
                        projectiles.push(new Projectile(cx, cy, dmgCross, d.x * speed, d.y * speed, false, "normal", this.isTraitor));
                    });
                    dirsX.forEach(d => {
                        projectiles.push(new Projectile(cx, cy, dmgX, d.x * speed, d.y * speed, false, "normal", this.isTraitor));
                    });
                }
                
                // Reiniciar timer tras disparar
                this.timer = 0;
                return; // Importante para que no ejecute l√≥gica de disparo est√°ndar
            }
        }
    }

    calculateChargeDamage() {
        const now = Date.now();
        const seconds = Math.floor((now - this.lastAttackTime) / 1000);
        let base = this.stats.baseDmg || 50; 
        let dmg = seconds * base;
        if (dmg === 0) return 0;
        let neighbors = heroes.filter(h => Math.abs(h.col - this.col) + Math.abs(h.y - this.y) === 1);
        let bonus = 0;
        neighbors.forEach(n => {
            if (n.name === "Soaphie") bonus += 2;
            if (n.name === "Stap") bonus += 3;
            if (n.name === "Doblap") bonus += 4;
            if (n.name === "Squap") bonus += 8;
            if (n.name === "Ninjap") bonus += 5;
        });
        return Math.max(0, dmg + (bonus * seconds));
    };

    activateAbility() {
        let dmg = this.calculateChargeDamage();
        if (dmg <= 0 && this.name !== "Ballge") { createPopup(this.realX, this.realY, "¬°Cargando!"); return; }
        if (this.name === "Spenge") {
            let p = new Projectile(this.col*80 + 80, this.y*80 + 40, dmg, 10, 0, true, true);
            p.isSpengeShot = true; 
            projectiles.push(p);
            this.lastAttackTime = Date.now();
            createPopup(this.realX, this.realY, "¬°BOOM!");
        } else if (this.name === "Ballge") {
            this.ballState = 'roll_fwd';
            this.ballDamageStored = dmg;
            this.ballVx = 8; this.ballVy = 0;
            this.ballHitSet.clear();
            this.timer = 0;
        }
    }

    updateBallPhysics() {
        this.realX += this.ballVx;
        this.realY += this.ballVy;
        if (this.realY <= 0 || this.realY >= 340) this.ballVy = -this.ballVy;
        let hit = false;
        enemies.forEach(e => {
            if (Math.abs((e.x + 30) - (this.realX + 30)) < 40 && Math.abs((e.y + 30) - (this.realY + 30)) < 40) {
                if (!this.ballHitSet.has(e)) {
                    e.takeDamage(this.ballDamageStored);
                    this.ballHitSet.add(e);
                    hit = true;
                }
            }
        });
        if (hit) {
            if (this.ballState === 'roll_fwd') {
                this.ballState = 'roll_diag';
                this.ballVx = 8;
                this.ballVy = Math.random() < 0.5 ? 8 : -8;
            } else {
                this.ballVy = -this.ballVy;
            }
        }
        if (this.realX > 800) {
            this.hp = 0;
            heroDies(this, true);
        }
        if (this.isCatapult) {
            // 1. FASE EST√ÅTICA
            if (!this.isRolling) {
                // Solo dispara si tiene un RIDER (H√©roe en la parte delantera)
                if (this.rider) {
                    this.timer++;
                    if (this.timer >= 120) { // 2 segundos
                        let pType = this.name.includes("Hielo") ? "ice_bomb" : "foam_bomb";
                        // Dispara desde el frente
                        projectiles.push(new Projectile(this.realX + 140, this.realY + 40, 20, 6, 0, false, pType));
                        this.timer = 0;
                    }
                }

                // Colisi√≥n con enemigos (Activa el rodar)
                // La catapulta ocupa col y col+1. Chequeamos si tocan la parte delantera o trasera.
                for (let en of enemies) {
                    if (en.row === this.y && en.x < this.realX + 150 && en.x > this.realX) {
                        this.activateRolling();
                        break; 
                    }
                }
            } 
            // 2. FASE RODANDO
            else {
                this.realX += 12; // Velocidad de embestida
                
                // Arrastrar al jinete visualmente
                if (this.rider) {
                    this.rider.realX = this.realX + 80;
                    this.rider.realY = this.realY;
                }

                // Destruir enemigos
                enemies.forEach(en => {
                    if (en.row === this.y && Math.abs(en.x - (this.realX + 80)) < 80) {
                        en.takeDamage(9999); // Instakill
                        createPopup(en.x, en.y, "¬°PLAF!", "red");
                    }
                });

                if (this.realX > 850) this.hp = 0; // Se va de la pantalla
            }
            return;
        }
    }
        activateRolling() {
            if (this.isRolling) return;
            this.isRolling = true;
            createPopup(this.realX, this.realY, "¬°A RODAR!", "orange");
        }
        toggleMode() {
    this.ninjaMode = (this.ninjaMode === 'cross' ? 'x' : 'cross');
    // Popup visual para informar al jugador
    createPopup(this.col * 80 + 40, this.y * 80 + 40, "¬°SWAP!", "white");
}

    draw() {
        if (this.isCatapult) {
            // Cuerpo de la catapulta (Ocupa 2 casillas de ancho visualmente)
            ctx.fillStyle = "#8d6e63"; // Marr√≥n madera
            // Parte Trasera
            ctx.fillRect(this.realX + 10, this.realY + 20, 60, 40);
            // Parte Delantera (Uni√≥n)
            ctx.fillRect(this.realX + 70, this.realY + 20, 60, 40);
            // Ruedas
            ctx.fillStyle = "#3e2723";
            ctx.beginPath(); ctx.arc(this.realX + 30, this.realY + 60, 15, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(this.realX + 110, this.realY + 60, 15, 0, Math.PI*2); ctx.fill();

            // Dibujar al Rider si existe
            if (this.rider) {
                // Dibujamos al h√©roe "montado" en la parte delantera (realX + 80)
                ctx.save();
                ctx.translate(this.realX + 80 - (this.rider.col*80), 0); // Ajuste visual relativo
                this.rider.realX = this.realX + 80; // Actualizamos coords para efectos
                this.rider.realY = this.realY;
                this.rider.draw(); // Reutilizamos su m√©todo draw
                ctx.restore();
            }
            
            // Barra de vida gigante
            ctx.fillStyle = "red";
            ctx.fillRect(this.realX + 20, this.realY - 10, 100 * (this.hp/this.maxHp), 6);
            return;
        }

        // Renderizado Catapulta Rodando o Ballge Rodando
        if ((this.name === "Ballge" && this.ballState !== 'idle') || (this.name.includes("Catapulta") && this.isRolling)) {
            if (this.name === "Ballge" && ballgeRollSprite.complete) {
                ctx.drawImage(ballgeRollSprite, this.realX + 10, this.realY + 10, 60, 60);
            } else {
                ctx.fillStyle = this.data.color;
                ctx.beginPath();
                ctx.arc(this.realX + 30, this.realY + 30, 30, 0, Math.PI*2);
                ctx.fill();
            }
            return; 
        }

        // Posici√≥n basada en grilla si no est√° rodando
        const x = this.col * 80 + 10;
        const y = this.y * 80 + 10; // Ahora this.y est√° definido, esto funcionar√°
        const w = 60;
        const h = 60;
        
        if (heroSprites[this.name] && heroSprites[this.name].complete && heroSprites[this.name].naturalWidth > 0) {
            try {
                ctx.drawImage(heroSprites[this.name], x, y, w, h);
            } catch (err) {
                this.drawFallback(x, y, w, h);
            }
        } else {
            this.drawFallback(x, y, w, h);
        }

        if (this.isProtected) {
            ctx.strokeStyle = "gold";
            ctx.lineWidth = 3;
            ctx.strokeRect(x-2, y-2, w+4, h+4);
            ctx.fillStyle = "gold";
            ctx.font = "16px Arial";
            ctx.fillText("üõ°", x + 40, y + 15);
        }

        if (this.name === "Ninjap" || this.name === "RunnerNinjap") {
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            // Dibuja + o X sobre el h√©roe
            ctx.fillText((this.ninjaMode === 'cross' || !this.ninjaMode) ? "+" : "X", x + 30, y + 45);
        }

        if (this.frozenTimer > 0) {
            ctx.fillStyle = "rgba(0, 255, 255, 0.35)";
            ctx.fillRect(x, y, w, h);
        }

        const hpPct = Math.max(0, this.hp / this.maxHp);
        ctx.fillStyle = "#0f0";
        ctx.fillRect(x, y - 8, w * hpPct, 6);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y - 8, w, 6);

        if (["Spenge", "Ballge"].includes(this.name)) {
            const secs = Math.floor((Date.now() - this.lastAttackTime)/1000);
            ctx.fillStyle = "white";
            ctx.font = "14px Arial";
            ctx.textAlign = "left";
            ctx.fillText(`${secs}s`, x + 4, y + h + 14);
        }

        if (this.isTraitor) {
            ctx.fillStyle = "purple"; 
            ctx.font = "20px Arial";
            ctx.fillText("üòµ", x + 30, y);
        }
        if (this.carriedHero) {
            ctx.save();
            ctx.translate(0, -10); 
            this.carriedHero.draw();
            ctx.restore();
        }
    }

    drawFallback(x, y, w, h) {
        ctx.fillStyle = this.data.color;
        ctx.fillRect(x, y, w, h);
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.data = ENEMIES_DATA[type];
        this.hp = this.data.hp; this.maxHp = this.data.hp;
        this.row = Math.floor(Math.random() * 5);
        this.eating = false; this.specialTimer = 0;
        this.teleportTimer = 0; 
        if (this.type === "Resortera") this.x = 9 * 80 + 10;
        else if (typeof gameState.level === 'number' && [10, 18, 36, 54, 86].includes(gameState.level)) this.x = 6 * 80 + 40 + Math.random() * 40;
        else this.x = 800;
        this.y = this.row * 80 + 10;
        this.slowTimer = 0;
        this.perfumeTimer = 0;
        this.speedMultiplier = 1;
        this.data = Object.assign({}, ENEMIES_DATA[type]); // Copia los datos para no afectar al original
        this.speed = this.data.speed;
        this.hasAccelerated = false;
    }

    takeDamage(amount, type="normal") {
        let finalDmg = amount;
        if (type === "ice") {
            if (this.data.isFire) finalDmg = 40;
            else if (this.data.isIce) finalDmg = 0;
            else this.slowTimer = 120;
        }
        else if (type === "fire") {
            if (this.data.isIce) finalDmg = 80;
            else if (this.data.isFire) finalDmg = 0;
            this.slowTimer = 0;
        }
        else if (type === "perfume") {
            this.perfumeTimer = 600;
        }
        this.hp -= finalDmg;
        createPopup(this.x, this.y, `-${finalDmg}`);
        if (this.hp <= 0) {
            this.calculateDrop();
        }
    }

    calculateDrop() {
        let coinProb = 0, billProb = 0;
        if (this.type === "Normal") { coinProb = 0.22; billProb = 0.03; }
        else if (this.type === "Sangre") { coinProb = 0.45; billProb = 0.05; }
        else if (this.type === "MasSangre") { coinProb = 0.90; billProb = 0.10; }
        else if (["Resortera", "Acuatico", "Hielo", "Fuego", "Velocista"].includes(this.type)) { coinProb = 0.80; billProb = 0.20; }
        else if (["Succionador", "Teleporter", "Vampiro", "Elastico", "Controlador"].includes(this.type)) { coinProb = 0.70; billProb = 0.30; }
        else if (this.type === "Super") { coinProb = 0.50; billProb = 0.50; }
        else if (this.type === "SuperRojo") { coinProb = 0; billProb = 1.0; }
        let r = Math.random();
        
        let coinsToAdd = 0;
        let billsToAdd = 0;

        if (r < billProb) {
            billsToAdd = 1;
            createPopup(this.x, this.y - 20, "+1üíµ", "lime");
        } else if (r < billProb + coinProb) {
            coinsToAdd = 10;
            createPopup(this.x, this.y - 20, "+10üí∞", "gold");
        }
        
        if (gameState.mode === 'infinite') {
            gameState.infinite.pendingCoins += coinsToAdd;
            gameState.infinite.pendingBills += billsToAdd;
        } else {
            gameState.coins += coinsToAdd;
            gameState.bills += billsToAdd;
        }
    }

    update() {
        if (this.isGrowMachine) {
            // Si est√° congelada, no cuenta el tiempo
            if (this.frozenTimer > 0) { this.frozenTimer--; return; }

            this.spawnTimer++;
            
            // 30 segundos * 60 frames = 1800
            if (this.spawnTimer >= 4800) {
                this.spawnTimer = 0; // Reiniciar contador
                
                // Pool exclusivo: Normal, Sangre, MasSangre
                const pool = ["Normal", "Sangre", "MasSangre"];
                const type = pool[Math.floor(Math.random() * pool.length)];
                
                // Crear el enemigo
                let germ = new Enemy(type);
                germ.row = this.row;
                germ.y = this.y;
                germ.x = this.x - 60; // Aparece un poco a la izquierda de la m√°quina
                
                enemies.push(germ);
                createPopup(this.x, this.y - 20, "¬°SPAWN!", "#ff00ff");
            }
            return; // IMPORTANTE: Return aqu√≠ para que la m√°quina no camine
        }
        let mult = 1;
        if (this.slowTimer > 0 && this.perfumeTimer > 0) mult = 0.25;
        else if (this.slowTimer > 0) { mult = 0.5; this.slowTimer--; }
        else if (this.perfumeTimer > 0) { mult = 0.5; this.perfumeTimer--; }
        this.speedMultiplier = mult;

        if (this.frozenTimer > 0) { this.frozenTimer--; return; }
        if (this.data.isAquatic) {
            this.specialTimer++;
            if (this.specialTimer >= 600) {
                // Actualizado: Se pasan todos los argumentos hasta llegar al ultimo 'true' (isEnemy)
                // (x, y, dmg, vx, vy, isPiercing, type, fromTraitor, isEnemy)
                projectiles.push(new Projectile(this.x, this.y + 40, 50, -5, 0, true, "normal", false, true));
                this.specialTimer = 0;
            }
        }
        if (this.data.isSucker) {
            this.specialTimer++;
            
            // Cada 10 segundos (600 frames) intenta succionar o activar
            if (this.specialTimer >= 600) {
                let targetHero = null;
                
                // Buscamos el h√©roe m√°s cercano en la misma fila
                // Priorizamos los que est√°n a la derecha del enemigo (frente a √©l)
                heroes.forEach(h => {
                    if (h.y === this.row && (h.col * 80) > this.x) {
                        if (!targetHero || h.col < targetHero.col) {
                            targetHero = h;
                        }
                    }
                });

                if (targetHero) {
                    // CASO A: Es una Catapulta
                    if (targetHero.isCatapult) {
                        targetHero.activateRolling(); // La catapulta sale disparada
                        createPopup(this.x, this.y, "¬°ACTIVACI√ìN!", "purple");
                    } 
                    // CASO B: Es un H√©roe Normal
                    else {
                        // Succi√≥n: Lo mueve una casilla hacia la derecha (hacia el enemigo/fuera)
                        if (targetHero.col < 9) {
                            targetHero.col++;
                            targetHero.realX = targetHero.col * 80 + 10; // Actualizamos posici√≥n visual
                            createPopup(targetHero.realX, targetHero.realY, "¬°SUCCI√ìN!", "magenta");
                        } else {
                            // Si ya est√° al borde, el h√©roe se pierde
                            heroDies(targetHero);
                            createPopup(this.x, this.y, "¬°DEVORADO!", "red");
                        }
                    }
                    this.specialTimer = 0; // Reiniciar cooldown tras √©xito
                }
            }
        }
        if (this.type === "Resortera") {
            this.specialTimer++;
            if (this.specialTimer > 400) {
                let e = new Enemy("Normal");
                e.x = 5 * 80 + 10; e.y = this.row * 80 + 10; e.row = this.row;
                enemies.push(e);
                this.specialTimer = 0;
            }
        }
        
        // Germen Velocista
        if (this.data.isSpeedster) {
            this.specialTimer++;
            // 600 frames son aprox 10 segundos
            if (this.specialTimer >= 600) {
                // Verificamos si ya aceler√≥ para que solo lo haga UNA vez
                if (!this.hasAccelerated) {
                    this.data.speed *= 2; // Multiplica SU velocidad individual
                    this.hasAccelerated = true; 

                    if (typeof createPopup === 'function') {
                        createPopup(this.x, this.y, "¬°R√ÅPIDO!", "yellow");
                    }
                }
                this.specialTimer = 0;
            }
        }
        
        // Germen El√°stico (Empuje)
        if (this.data.isElastic) {
            this.specialTimer++;
            if (this.specialTimer >= 600) { // 10 seg
                createPopup(this.x, this.y, "¬°BOING!", "pink");
                heroes.forEach(h => {
                    if (h.y === this.row) {
                        h.hp -= 25;
                        if (h.col === 0) heroDies(h, false); // Matar si est√° al fondo
                        else {
                            h.col--; 
                            h.realX = h.col * 80 + 10; // Mover visualmente
                        }
                    }
                });
                this.specialTimer = 0;
            }
        }

        // 3. Control Mental (Vampiro/Controller)
        if ((this.data.isVampire || this.data.isController) && ++this.specialTimer >= 600) {
            let target = this.data.isController ? 
                heroes[Math.floor(Math.random() * heroes.length)] : 
                heroes.find(h => h.y === this.row && Math.abs((h.col * 80) - this.x) < 100);

            if (target && target.name !== "Vampierce" && !target.name.startsWith("Catapulta")) {
                target.isTraitor = true;
                target.traitorTimer = 300;
                createPopup(target.col * 80, target.y * 80, "¬°CONTROLADO!", "purple");
            }
            this.specialTimer = 0;
        }

        // 4. COLISI√ìN Y ATAQUE (Corregido)
        this.eating = false;
        for (let h of heroes) {
            if (h.isTraitor) continue; // IGNORA COMPLETAMENTE A LOS CONTROLADOS

            if (h.name === "Pastual") {
                if (h.y === this.row && Math.abs(this.x - h.realX) < 40) {
                    this.perfumeTimer = 10;
                    if (this.speedMultiplier > 0.25) this.speedMultiplier = 0.25;
                }
                continue; // Esto hace que el enemigo ignore a Pastual y siga caminando
            }

            if (h.y === this.row && this.x < (h.col * 80 + 60) && this.x + 40 > h.col * 80) {
                this.eating = true;
                if (this.data.isFire) { h.hp = 0; heroDies(h); }
                else if (this.data.isIce) { h.frozenTimer = 600; }
                else {
                    h.hp -= this.data.damage / 60;
                    if (h.hp <= 0) heroDies(h);
                }
                break; 
            }
        }

        // 5. Movimiento
        if (!this.eating && this.type !== "Resortera") {
            this.x -= (this.data.speed * this.speedMultiplier);
        }

        if (this.x < 0) endGame("¬°Entraron a la ciudad!");

        function updateCatapult(hero) {
        if (hero.name.includes("Catapulta")) {
            hero.timer = (hero.timer || 0) + 1;
            
            // Disparo cada 2 segundos (aprox 120 frames)
            if (hero.timer >= 120) {
                let pType = hero.name === "CatapultaHielo" ? "ice_bomb" : "foam_bomb";
                // USAR 'new Projectile' asigna autom√°ticamente vx, vy y el m√©todo update()
                projectiles.push(new Projectile(hero.x + 80, hero.y + 20, 20, 5, 0, false, pType));
                hero.timer = 0;
            }

            // L√≥gica de "Atropello" si un germen la toca
            enemies.forEach(enemy => {
                if (enemy.row === hero.row && enemy.x <= hero.x + 40 && !hero.isRolling) {
                    hero.isRolling = true;
                }
            });

            if (hero.isRolling) {
                hero.x += 10; // Velocidad de desplazamiento
                enemies.forEach(enemy => {
                    if (enemy.row === hero.row && Math.abs(enemy.x - hero.x) < 40) {
                        enemy.hp = 0; // Destruye al germen
                    }
                });
                if (hero.x > INTERNAL_WIDTH) hero.hp = 0; // Se elimina al salir
            }
            let blocker = heroes.find(h => h.y === this.row && Math.abs((h.col * 80) - this.x) < 40);
            if (blocker) {
                if (blocker.isCatapult) {
                    // Si choca con la catapulta f√≠sicamente, tambi√©n la activa
                    blocker.activateRolling();
                } else {
                    // Ataque normal
                    blocker.hp -= this.data.dmg;
                    if (blocker.hp <= 0) heroDies(blocker);
                    return; // Se detiene al atacar
                }
            }
            let currentMove = this.speed; 
            if (this.isSlowed) currentMove *= 0.5;
            this.x -= currentMove;
        }
    }
}

draw() {
    // --- DIBUJO DE M√ÅQUINA AGRANDADORA ---
    if (this.isGrowMachine) {
        // Caja met√°lica oscura
        ctx.fillStyle = "#444"; 
        ctx.fillRect(this.x, this.y, 60, 60);
        
        // Borde "industrial"
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x, this.y, 60, 60);

        // Puerto de salida (parpadea cuando est√° cerca de generar)
        let portColor = (this.spawnTimer > 4700) ? "#ff00ff" : "#222";
        ctx.fillStyle = portColor;
        ctx.beginPath();
        ctx.arc(this.x + 30, this.y + 30, 15, 0, Math.PI*2);
        ctx.fill();

        // Barra de vida integrada
        ctx.fillStyle = "red";
        ctx.fillRect(this.x, this.y - 8, 60 * (this.hp / this.maxHp), 5);
        return;
    }
    // 2. DIBUJO DE SPRITES ANIMADOS
    const framesList = enemyFrames[this.type];
    
    // Verificar si hay frames cargados para este tipo
    if (framesList && framesList.length > 0) {
        // VELOCIDAD DE ANIMACI√ìN:
        // gameState.levelFrame aumenta 60 veces por seg.
        // Dividimos por 10 para cambiar de frame cada 10 ticks (6 veces por seg).
        // Ajusta el '10' si quieres que corran m√°s r√°pido o lento.
        const speedFactor = 10; 
        const frameIndex = Math.floor(gameState.levelFrame / speedFactor) % framesList.length;
        const currentImg = framesList[frameIndex];

        if (currentImg.complete) {
             // Dibujar imagen centrada (60x60 px)
            ctx.drawImage(currentImg, this.x, this.y, 60, 60);
        }
    } else {
        // FALLBACK: Si no hay im√°genes, dibuja la bola de color original
        ctx.fillStyle = this.data.color;
        ctx.beginPath();
        ctx.arc(this.x + 30, this.y + 30, 25, 0, Math.PI*2);
        ctx.fill();
        if (this.speedMultiplier < 1) { ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke(); }
    }

    // Barra de vida
    ctx.fillStyle = "yellow";
    ctx.fillRect(this.x + 10, this.y - 5, 40 * (Math.max(0, this.hp) / this.maxHp), 4);
}
}

class Projectile {
    constructor(x, y, dmg, vx, vy, isPiercing = false, type = "normal", fromTraitor = false, isEnemy = false) {
        this.x = x;
        this.y = y;
        this.dmg = dmg;
        this.vx = vx;
        this.vy = vy;
        this.isPiercing = isPiercing;
        this.type = type;
        this.fromTraitor = fromTraitor;
        this.isDead = false;
        this.hitTargets = new Set();
        this.hitBoss = false;
        this.generateEnergy = false;  // Para Elenectrica (probabilidad de generar rayo)
        this.color = fromTraitor ? "purple" : (isEnemy ? "blue" : "white");

        // Color seg√∫n tipo
        this.color = fromTraitor ? "purple" : "white";
        if (type === "ice") this.color = "cyan";
        if (type === "fire") this.color = "orange";
        if (type === "perfume") this.color = "violet";
        if (type === "laser") this.color = "#aa00ff";
        if (type === "foam_bomb") this.color = "#eee";
        if (type === "ice_bomb") this.color = "#a5f2f3";
        if (type === "electric") this.color = "#ffff33";
        if (type === "roostert_blade") this.color = "#ffd700";
    }

    update() {
        // Movimiento (esto es lo que faltaba en la versi√≥n anterior)
        this.x += this.vx;
        this.y += this.vy;

        // Fuera de pantalla ‚Üí eliminar
        if (this.x < -50 || this.x > canvas.width + 50 || 
            this.y < -50 || this.y > canvas.height + 50) {
            this.isDead = true;
            return;
        }

        // Determinar objetivos seg√∫n si es proyectil traidor o normal
        const targets = (this.fromTraitor || this.isEnemy) 
            ? heroes.filter(h => !h.isTraitor && h.hp > 0)
            : enemies.filter(e => e.hp > 0);

        for (let t of targets) {
            if (this.isDead) break;

            const tx = t instanceof Enemy ? t.x + 30 : (t.col * 80 + 40);
            const ty = t instanceof Enemy ? t.y + 30 : (t.row * 80 + 40);

            if (Math.hypot(this.x - tx, this.y - ty) < 35 && !this.hitTargets.has(t)) {
                if (t instanceof Enemy) {
                    // L√≥gica de impacto contra Enemigos
                    if (this.type === "roostert_blade") {
                        const bloqueadores = ["Sangre", "MasSangre", "SuperRojo"];
                        if (bloqueadores.includes(t.type)) {
                            t.takeDamage(this.dmg);
                            this.isDead = true;
                        } else {
                            t.takeDamage(99999); 
                        }
                    }
                    else if (this.type === "foam_bomb" || this.type === "ice_bomb") {
                        const puddleType = this.type === "foam_bomb" ? "foam" : "ice";
                        puddles.push(new Puddle(t.x, t.y, puddleType));
                        t.takeDamage(this.dmg);
                    }
                    else {
                        t.takeDamage(this.dmg, this.type);
                        if (this.type === "electric" && this.generateEnergy && Math.random() < 0.25) {
                            produceRay(this.x, this.y);
                        }
                        if (this.type === "explosive_spike" && Math.random() < 0.25) {
                            createExplosionArea(this.x, this.y, 50, this.fromTraitor);
                        }
                    }

                    if (!this.isPiercing) {
                        this.isDead = true;
                    } else if (this.type !== "roostert_blade") {
                        t.hp -= this.dmg * 0.5;
                        if (t.hp <= 0) enemyDies(t);
                    }
                } 
                else {
                    // L√≥gica de impacto contra H√©roes (Da√±o al jugador)
                    t.hp -= this.dmg;
                    createPopup(t.realX, t.realY, `-${this.dmg}`, "red"); // Feedback visual
                    if (t.hp <= 0) heroDies(t);
                    if (!this.isPiercing) this.isDead = true;
                }
                this.hitTargets.add(t);
            }
        }

        // Da√±o al jefe (solo si NO es traidor NI enemigo)
        if (!this.fromTraitor && !this.isEnemy && !this.isDead && 
            typeof gameState.level === "number" && 
            [10, 18, 36, 54, 86].includes(gameState.level)) {
            checkBossHit(this);
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        
        // Bombas un poco m√°s grandes para que se vean mejor
        const radius = (this.type === "foam_bomb" || this.type === "ice_bomb") ? 10 : 5;
        
        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Opcional: borde sutil para que resalten m√°s
        if (this.type === "roostert_blade" || this.type === "electric") {
            ctx.strokeStyle = "rgba(255,255,255,0.6)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

let puddles = [];

class Puddle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'foam' o 'ice'
        this.timer = 300; // 5 segundos de vida (60 frames x 5)
    }

    update() {
        this.timer--;
        // Da√±o por segundo (5 da√±o / 60 frames = 0.0833 por frame)
        if (this.type === 'foam') {
            enemies.forEach(e => {
                // Si pisa el charco (misma fila y coordenadas cercanas)
                if (e.row === Math.floor(this.y/80) && Math.abs((e.x + 30) - (this.x + 40)) < 40) {
                    e.takeDamage(0.0833); 
                }
            });
        }
    }

    draw() {
        ctx.fillStyle = this.type === 'foam' ? "rgba(255, 255, 255, 0.6)" : "rgba(100, 200, 255, 0.6)";
        ctx.beginPath();
        // Dibujamos una elipse para simular el charco en el suelo
        ctx.ellipse(this.x + 40, this.y + 70, 35, 15, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

class SpawnerMachine {
    constructor(row, col) {
        this.row = row;
        this.col = col;
        this.x = col * CELL_W;
        this.y = row * CELL_H;
        this.hp = 200;
        this.timer = 0;
        this.active = false;
        setTimeout(() => this.active = true, 30000); // Aparecen/Activan a los 30s
    }

    update() {
        if (!this.active) return;
        this.timer++;
        if (this.timer >= 1200) { // Cada 20 segundos (1200 frames)
            const pool = ["Normal", "Sangre", "MasSangre"];
            const type = pool[Math.floor(Math.random() * pool.length)];
            spawnEnemy(type, this.row, this.x);
            this.timer = 0;
        }
    }

    draw() {
        if (!this.active) return;
        ctx.fillStyle = "#555"; // Color de la m√°quina
        ctx.fillRect(this.x + 10, this.y + 10, 60, 60);
        // Barra de vida simple
        ctx.fillStyle = "red";
        ctx.fillRect(this.x + 10, this.y + 5, (this.hp / 200) * 60, 5);
    }
}

function produceRay(x, y) {
    gameState.rayos++;
    gameState.producedRaysCount++;
    createPopup(x, y - 20, "+1‚ö°");
    updateUI();
}

function heroDies(hero, byMechanic) {
    if (hero.deadProcessed) return;
    hero.deadProcessed = true;
    hero.hp = 0;
    gameState.heroesLostCount++;
    if (gameState.level === 17 && gameState.heroesLostCount > 5) endGame("¬°Perdiste demasiados h√©roes!");
    if (gameState.level === 27 && gameState.heroesLostCount > 10) endGame("¬°Max 10 bajas!");
    if (gameState.level === 31 && gameState.heroesLostCount > 5) endGame("¬°Max 5 bajas!");
    if (gameState.level === 34 && gameState.heroesLostCount > 15) endGame("¬°Max 15 bajas!");
    if (gameState.level === 39 && gameState.heroesLostCount > 15) endGame("¬°Max 15 bajas!");
    if (gameState.level === 41 && hero.name === "Reactor" && hero.col === 5 && !byMechanic) endGame("¬°Perdiste el reactor protegido!");
    if (gameState.level === 42 && hero.name === "Squap" && hero.col === 0 && !byMechanic) endGame("¬°Perdiste Squap protegido!");
    if (gameState.level === 45 && hero.name === "RunnerSoaphie" && !byMechanic) endGame("¬°Runner Soaphie muri√≥!");
    if (gameState.level === 52 && hero.name === "Lypia" && hero.col === 0 && !byMechanic) endGame("¬°Lypia protegida muri√≥!");
    updateUI();
}

/** * INTERACCI√ìN RAT√ìN Y T√ÅCTIL CORREGIDA */
function handleInput(clientX, clientY) {
    if (gameState.gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const realX = (clientX - rect.left) * scaleX;
    const realY = (clientY - rect.top) * scaleY;

    const col = Math.floor(realX / CELL_W);
    const row = Math.floor(realY / CELL_H);
    
    if (col < 0 || col >= 10 || row < 0 || row >= 5) return;

    // --- NUEVO: CHEQUEO DE M√ÅQUINA ---
    // Buscar si hay una m√°quina en esa posici√≥n
    let machineHere = enemies.find(e => e.isGrowMachine && e.row === row && Math.floor(e.x / 80) === col);
    
    // Si estamos en modo borrar (Trash), PERMITIMOS clicar para ver info o nada, 
    // pero si vamos a construir (selectedHero existe), bloqueamos.
    if (machineHere && gameState.selectedHero && !gameState.isTrashing) {
         createPopup(col * 80 + 40, row * 80 + 40, "‚õî M√ÅQUINA", "red");
         return; // Cancela la construcci√≥n
    }
    
    // Buscar si ya hay un h√©roe en esa casilla
    let clickedHero = heroes.find(h => h.col === col && h.y === row);
    
    // Check restrictions from current level data
    const lvlData = gameState.currentLevelData || LEVELS[Math.min(gameState.level - 1, LEVELS.length-1)];
    if (lvlData.forbiddenRows && lvlData.forbiddenRows.includes(row)) return;
    if (lvlData.forbiddenCols && lvlData.forbiddenCols.includes(col)) return;

    // 1. MODO BORRAR (TRASH)
    if (gameState.isTrashing) {
        if (clickedHero) {
            // Protecciones de nivel
            if (gameState.level === 41 && clickedHero.name === "Reactor" && clickedHero.col === 5) return;
            if (gameState.level === 42 && clickedHero.name === "Squap" && clickedHero.col === 0) return;
            if (gameState.level === 45 && clickedHero.name === "RunnerSoaphie") return;
            if (gameState.level === 52 && clickedHero.name === "Lypia" && clickedHero.col === 0) return;
            
            let refundMult = 0;
            if (gameState.trashUpgrade2) refundMult = 0.50;
            else if (gameState.trashUpgrade) refundMult = 0.25;
            let refund = Math.floor(clickedHero.stats.cost * refundMult);
            gameState.rayos += refund;
            createPopup(clickedHero.realX, clickedHero.realY, `+${refund}‚ôª`);
            heroDies(clickedHero, true);
        }
    } 
    // 2. INTERACCI√ìN CON H√âROE EXISTENTE (Habilidades / Knap)
    else if (clickedHero) {
        // Habilidades activas
        if (clickedHero.name === "Spenge" || clickedHero.name === "Ballge") {
            clickedHero.activateAbility();
        }
        else if (clickedHero.name === "Ninjap" || clickedHero.name === "RunnerNinjap") {
            clickedHero.toggleMode();
        }
        // L√≥gica especial de Knap (Apilar h√©roe encima)
        else if (clickedHero.name === "Knap" && !clickedHero.carriedHero && gameState.selectedHero && gameState.selectedHero !== "Knap") {
             const now = Date.now();
             const cdEnd = gameState.heroCurrentReloads[gameState.selectedHero] || 0;
             if (now < cdEnd) {
                 createPopup(col*80, row*80, "¬°Recargando!", "gray");
                 return;
             }
             
             let lvl = gameState.inventory[gameState.selectedHero].level;
             let hStats = getHeroStats(gameState.selectedHero, lvl);
             
             if (gameState.rayos >= hStats.cost) {
                 clickedHero.carriedHero = new Hero(col, row, gameState.selectedHero);
                 gameState.rayos -= hStats.cost;
                 gameState.raysSpent += hStats.cost;
                 
                 const reloadSecs = HEROES_INFO[gameState.selectedHero].reload || 5;
                 gameState.heroCurrentReloads[gameState.selectedHero] = now + (reloadSecs * 1000);
                 updateUI();
             }
        }
    }
    // 3. COLOCACI√ìN EN CASILLA VAC√çA
    else if (gameState.selectedHero) {
        let isBossLevel = typeof gameState.level === 'number' && [10, 18, 36, 54, 86].includes(gameState.level);
        if (isBossLevel) {
             if (col >= 6) {
                 createPopup(col*80, row*80, "‚õî ZONA PELIGROSA", "red");
                 return;
             }
        }
        if (col < (gameState.level >= 10 ? 9 : 10)) {
            // Restricciones de nivel
            if (lvlData.constraint === "maxHeroes20" && heroes.length >= 20) {
                createPopup(col*80, row*80, "¬°MAX 20!");
                return;
            }
        if (col < (gameState.level >= 10 ? 9 : 10)) {
        // Restricciones de nivel
        if (lvlData.constraint === "maxHeroes40" && heroes.length >= 20) {
            createPopup(col*80, row*80, "¬°MAX 40!");
            return;
        }
    }
            
            const now = Date.now();
            const cdEnd = gameState.heroCurrentReloads[gameState.selectedHero] || 0;
            if (now < cdEnd) {
                createPopup(col*80, row*80, "¬°Recargando!", "gray");
                return;
            }

            let lvl = gameState.inventory[gameState.selectedHero].level;
            let hStats = getHeroStats(gameState.selectedHero, lvl);
            
            if (lvlData.constraint === "spendMax40" && (gameState.raysSpent + hStats.cost > 40)) {
                createPopup(col*80, row*80, "¬°Limite Gasto!");
                return;
            }
            if (lvlData.constraint === "spendMax150" && (gameState.raysSpent + hStats.cost > 150)) {
                createPopup(col*80, row*80, "¬°Limite Gasto!");
                return;
            }

            // --- L√ìGICA DE COLOCACI√ìN CORREGIDA ---
            if (gameState.rayos >= hStats.cost) {
                heroes.push(new Hero(col, row, gameState.selectedHero));
                gameState.rayos -= hStats.cost;
                gameState.raysSpent += hStats.cost;
                const reloadSecs = HEROES_INFO[gameState.selectedHero].reload || 5;
                gameState.heroCurrentReloads[gameState.selectedHero] = now + (reloadSecs * 1000);
                updateUI();
            }
        }
    }
}

canvas.addEventListener('mousedown', (e) => {
    handleInput(e.clientX, e.clientY);
});
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); 
    if (e.touches.length > 0) {
        handleInput(e.touches[0].clientX, e.touches[0].clientY);
    }
}, { passive: false });

// 1. A√ëADE ESTA FUNCI√ìN checkBossHit COMPLETA (p√©gala antes de gameLoop(), por ejemplo despu√©s de drawBossLevel())
function checkBossHit(p) {
    // Solo en niveles de jefe
    if (typeof gameState.level !== 'number' || ![10, 18, 36, 54, 86].includes(gameState.level)) return;

    // Zona del jefe: x >= 640 (columna 8 en adelante)
    if (!p.fromTraitor && p.x >= 640 && !p.hitBoss) {
        let damage = p.dmg;

        // Bonos opcionales por tipo (ajusta si quieres)
        if (p.type === 'fire') damage *= 1.5;
        if (p.type === 'ice') damage *= 0.8;
        if (p.type === 'electric') damage *= 1.2;

        gameState.bossHP -= damage;
        p.hitTargets.add("boss");  // ‚Üê CLAVE: Marca como golpeado (UNA VEZ por proyectil)
        p.hitBoss = true;          // ‚Üê Por compatibilidad

        // Popup de da√±o (visual feedback)
        createPopup(p.x, p.y - 10, `-${Math.floor(damage)}`, 'red');

        // No perforante = muere al golpear jefe
        if (!p.isPiercing) p.isDead = true;
    }

    // Da√±o a M√ÅQUINAS (columna 7, si existen)
    if (gameState.machines) {
        gameState.machines.forEach(m => {
            if (m.hp <= 0 || p.isDead) return;
            const mx = 560 + 30;  // 7*80 + 30
            const my = m.row * 80 + 40;
            const dist = Math.hypot(p.x - mx, p.y - my);
            if (dist < 35 && !p.hitTargets.has(m)) {
                m.hp -= p.dmg;
                p.hitTargets.add(m);
                createPopup(mx, my, `-${p.dmg}`, 'yellow');
                if (!p.isPiercing) p.isDead = true;
                if (m.hp <= 0) createPopup(mx, my + 20, '¬°DESTRUIDA!', 'orange');
            }
        });
    }
}

/** * BUCLE PRINCIPAL */
function gameLoop() {
    ctx.clearRect(0,0,800,400); // Limpieza base

    // DIBUJAR FONDO
    if (currentBgImage.complete && currentBgImage.naturalWidth > 0) {
        ctx.drawImage(currentBgImage, 0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);
    } else {
        ctx.fillStyle = "#222"; // Color de respaldo mientras carga
        ctx.fillRect(0, 0, INTERNAL_WIDTH, INTERNAL_HEIGHT);
    }
    if (gameState.gameOver) return;
    updateHeroCooldowns();

    // ctx.clearRect(0,0,800,400);
    let isBossLevel = typeof gameState.level === 'number' && [10, 18, 36, 54, 86].includes(gameState.level);
    gameState.levelFrame++;
    
    // Obtener datos del nivel actual (sea historia o infinito)
    const lvlData = gameState.currentLevelData;

    for(let r=0; r<5; r++) for(let c=0; c<10; c++) {
        let isRestricted = false;
        if (lvlData.forbiddenRows && lvlData.forbiddenRows.includes(r)) isRestricted = true;
        if (lvlData.forbiddenCols && lvlData.forbiddenCols.includes(c)) isRestricted = true;
        if (isBossLevel && c >= 6) isRestricted = true;
        if (isRestricted) {
            ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
            ctx.fillRect(c*80, r*80, 80, 80);
            ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
            ctx.beginPath();
            ctx.moveTo(c*80, r*80); ctx.lineTo(c*80+80, r*80+80);
            ctx.moveTo(c*80+80, r*80); ctx.lineTo(c*80, r*80+80);
            ctx.stroke();
        }
        ctx.strokeStyle = "#444";
        ctx.strokeRect(c*80, r*80, 80, 80);
    }

    if (isBossLevel) drawBossLevel();

    if (isBossLevel && gameState.levelFrame >= 1200) {  
        gameState.machines.forEach(m => {
            if (m.hp <= 0) return;
            if (m.hp > 0) {
                m.spawnTimer++;
                if (m.spawnTimer >= 1100) {  
                    let row = m.row;
                    let e = new Enemy("Normal");
                    e.row = row; e.x = 6 * 80 + 20 + Math.random() * 40; e.y = row * 80 + 10;
                    
                    let r = Math.random();
                    let type;
                    if (gameState.level === 86) {
                        if (r < 0.15) type = "Normal";
                        else if (r < 0.40) type = "Sangre";
                        else if (r < 0.50) type = "MasSangre";
                        else if (r < 0.60) type = "Teleporter";
                        else if (r < 0.65) type = "Acuatico";
                        else if (r < 0.70) type = "Succionador";
                        else if (r < 0.75) type = "Vampiro";
                        else if (r < 0.80) type = "Controlador";
                        else if (r < 0.85) type = "Elastico";
                        else if (r < 0.90) type = "Velocista";
                        else if (r < 0.97) type = "Super";
                        else type = "SuperRojo";
                    } else if (gameState.level === 54) {
                        if (r < 0.25) type = "Normal";
                        else if (r < 0.50) type = "Sangre";
                        else if (r < 0.60) type = "MasSangre";
                        else if (r < 0.70) type = "Teleporter";
                        else if (r < 0.75) type = "Acuatico";
                        else if (r < 0.80) type = "Succionador";
                        else if (r < 0.85) type = "Hielo";
                        else if (r < 0.90) type = "Fuego";
                        else if (r < 0.99) type = "Super";
                        else type = "SuperRojo";
                    } else if (gameState.level === 36) {
                        if (r < 0.30) type = "Normal";
                        else if (r < 0.55) type = "Sangre";
                        else if (r < 0.65) type = "MasSangre";
                        else if (r < 0.75) type = "Acuatico";
                        else if (r < 0.85) type = "Succionador";
                        else if (r < 0.90) type = "Hielo";
                        else if (r < 0.95) type = "Fuego";
                        else type = "Super";
                    } else if (gameState.level === 18) {
                        if (r < 0.50) type = "Normal";
                        else if (r < 0.75) type = "Sangre";
                        else if (r < 0.85) type = "MasSangre";
                        else if (r < 0.95) type = "Acuatico";
                        else type = "Super";
                    } else {  
                        type = r < 0.5 ? "Normal" : (r < 0.8 ? "Sangre" : (r < 0.95 ? "MasSangre" : "Super"));
                    }
                    e.type = type;
                    e.data = ENEMIES_DATA[type]; e.hp = e.data.hp; e.maxHp = e.data.hp;
                    enemies.push(e);
                    createPopup(e.x, e.y, "¬°M√ÅQUINA!", "yellow");
                    m.spawnTimer = 0;
                }
            } else {
                m.respawnTimer++;
                if (m.respawnTimer >= 1200) { 
                    m.hp = m.maxHp;
                    m.spawnTimer = 0; m.respawnTimer = 0;
                    createPopup(7*80 + 40, m.row * 80 + 40, "¬°REPARADA!", "orange");
                }
            }
        }
    )}
    gameState.spawnTimer++;
    let canSpawn = gameState.enemiesToSpawn > 0;
    if (!isBossLevel && canSpawn) {
        gameState.spawnTimer++;
        if (gameState.spawnTimer >= gameState.currentSpawnInterval) {
            const spawnedSoFar = gameState.totalEnemies - gameState.enemiesToSpawn;
            let type;
            const progress = spawnedSoFar / gameState.totalEnemies;
            
            if (progress < 0.2) { type = "Normal"; } 
            else {
                let effectivePool = lvlData.pool;
                if (gameState.level === 17 && gameState.superSpawned >= 3) { effectivePool = effectivePool.filter(t => t !== "Super"); }
                if (lvlData.pool.includes("Super") && lvlData.pool.length > 1) {
                    if (spawnedSoFar < Math.ceil(gameState.totalEnemies / 2)) { effectivePool = lvlData.pool.filter(t => t !== "Super"); }
                }
                if (lvlData.pool.includes("SuperRojo") && lvlData.pool.length > 1) {
                    if (spawnedSoFar < Math.ceil(gameState.totalEnemies * 0.75)) { effectivePool = lvlData.pool.filter(t => t !== "SuperRojo"); }
                }
                type = effectivePool[Math.floor(Math.random() * effectivePool.length)];
            }
            enemies.push(new Enemy(type));
            gameState.enemiesToSpawn--;
            gameState.spawnedCount++;
            if (type === "Super") gameState.superSpawned++;
            gameState.spawnTimer = 0;

            if (gameState.currentSpawnInterval > 60) {
                gameState.currentSpawnInterval -= gameState.intervalDecrement;
                if (gameState.currentSpawnInterval < 60) gameState.currentSpawnInterval = 60;
            }
            updateUI();
        }
        puddles = puddles.filter(p => p.timer > 0);
        puddles.forEach(p => { p.update(); p.draw(); });
    }
    
    if (!isBossLevel && gameState.enemiesToSpawn <= 0 && enemies.length === 0) {
        if (gameState.level === 13 && gameState.producedRaysCount < 50) endGame("Faltan Rayos (50)");
        else if (gameState.level === 21 && gameState.producedRaysCount < 150) endGame("Faltan Rayos (150)");
        else if ((gameState.level === 32 || gameState.level === 49) && gameState.killObjFailed) endGame("Fallaste objetivo distancia");
        else winLevel();
    }
    if (isBossLevel && gameState.bossHP <= 0) winLevel();
    
    heroes = heroes.filter(h => h.hp > 0);
    heroes.forEach(h => { h.update(); h.draw(); });
    enemies = enemies.filter(e => {
        if (e.hp <= 0) {
            if (gameState.level === 32 || gameState.level === 49) {
                if (e.x > 6 * 80) gameState.killObjCount++;
            }
            return false;
        }
        return true;
    });
    if (gameState.level === 32 || gameState.level === 49) {
      if (gameState.enemiesToSpawn === 0 && enemies.length === 0 && gameState.killObjCount < 10) gameState.killObjFailed = true;
    }
    enemies.forEach(e => { e.update(); e.draw(); });
    projectiles = projectiles.filter(p => !p.isDead);
    projectiles.forEach(p => {
        p.update();
        p.draw();
    });
    popups.forEach(p => {
        ctx.fillStyle = p.color || "white"; ctx.fillText(p.text, p.x, p.y); p.y--; p.life--;
    });
    popups = popups.filter(p => p.life > 0);
    requestAnimationFrame(gameLoop);
}

function drawBossLevel() {
    let color = "#4a148c";
    if (gameState.level === 18) color = "#2c003e";
    if (gameState.level === 36) color = "#000";
    if (gameState.level === 54) color = "#220000";
    if (gameState.level === 86) color = "#220000";
    ctx.fillStyle = color;
    ctx.fillRect(8*80, 0, 160, 400);
    
    let maxBossHP = 20000;
    if(gameState.level===18) maxBossHP = 30000;
    if(gameState.level===36) maxBossHP = 30000;
    if(gameState.level===54) maxBossHP = 40000;
    if(gameState.level===86) maxBossHP = 40000;
    ctx.fillStyle = "lime";
    ctx.fillRect(8*80+10, 30, 140*(Math.max(0,gameState.bossHP)/maxBossHP), 10);
    ctx.fillStyle = "white";
    ctx.font = "16px Arial";
    ctx.fillText(Math.floor(gameState.bossHP), 8*80+10, 25);
    
    let maxMHP = 200;
    if (gameState.level === 18) maxMHP = 500;
    else if (gameState.level >= 36) maxMHP = 1000;
    else if (gameState.level === 54 || gameState.level === 86) maxMHP = 1500;
    gameState.machines.forEach(m => {
        if (m.hp > 0) {
            ctx.fillStyle = "#757575";
            ctx.fillRect(7*80+10, m.row*80+10, 60, 60);
            let hpPct = m.hp / maxMHP;
            ctx.fillStyle = hpPct > 0.5 ? "lime" : (hpPct > 0.25 ? "orange" : "red");
            ctx.fillRect(7*80+15, m.row*80+30, 50 * hpPct, 10);
            
            if (gameState.levelFrame >= 1200) {
                ctx.fillStyle = "rgba(255,0,0,0.5)";
                ctx.fillRect(7*80+10, m.row*80+10, 60, 60);
                ctx.fillStyle = "white";
                ctx.font = "12px Arial";
                ctx.fillText("ACT", 7*80+20, m.row*80+45);
            }
        }
    });
}

function winLevel() {
    gameState.gameOver = true;
    
    // BRANCH INFINITE MODE
    if (gameState.mode === 'infinite') {
        saveInfiniteBoard(); // GUARDAMOS EL ESTADO DE LA DEFENSA AQU√ç
        saveProgress(); // Guardar antes de elegir carta
        showDraftScreen();
        return;
    }
    
    // STORY MODE
    let isReplay = gameState.level < gameState.maxLevel;
    if (gameState.level === gameState.maxLevel) {
        gameState.maxLevel = Math.min(gameState.maxLevel + 1, 86);
        if ([10, 18, 36, 54, 86].includes(gameState.level)) {
             alert("¬°JEFE DERROTADO! ¬°Recompensa Especial: MEGASOBRE!");
             openPack(true); 
        } else {
             openPack(false);
        }

    } else {
        gameState.coins += 50;
        gameState.bills += 1;
        alert("¬°Nivel Repetido Superado!\nRecompensa: 50 Monedas, 1 Billete.");
    }

    if (!gameState.dailyPlayed.includes(gameState.level)) {
        if (gameState.dailyPlayed.length < 5) {
            gameState.dailyPlayed.push(gameState.level);
            giveMiniPack(); 
        }
    }

    saveProgress();
    document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
    document.getElementById('menu-screen').style.display = 'block';
    document.getElementById('overlay').style.display = 'none';
    renderLevelGrid();
    updateInfiniteButton();
}

function endGame(msg) {
    gameState.gameOver = true;
    
    // Si estamos en modo infinito, reiniciamos el progreso infinito PERO reclamamos lo ganado
    if (gameState.mode === 'infinite') {
         claimInfiniteRewards();
         gameState.infinite.active = false;
         gameState.infinite.wave = 1;
         gameState.infinite.pool = ["Reactor", "Soaphie"];
         gameState.infinite.deck = ["Reactor", "Soaphie"];
         gameState.infinite.savedBoard = []; // Limpiar tablero guardado
         saveProgress();
    }
    
    document.getElementById('overlay-title').innerText = "¬°DERROTA!";
    document.getElementById('overlay-msg').innerText = msg || "";
    document.getElementById('overlay').style.display = 'flex';
}

function createPopup(x, y, text, color="white") { popups.push({x, y, text, life: 40, color}); }

function updateUI() {
    document.getElementById('rayos-display').innerText = gameState.rayos;
    const objDisplay = document.getElementById('special-obj-display');
    const limitDisplay = document.getElementById('limit-obj-display');
    objDisplay.style.display = "none";
    limitDisplay.style.display = "none";
    if (gameState.level === 13) {
        objDisplay.style.display = "block";
        objDisplay.innerText = `Prod: ${gameState.producedRaysCount}/50`;
    } else if (gameState.level === 21) {
        objDisplay.style.display = "block";
        objDisplay.innerText = `Prod: ${gameState.producedRaysCount}/150`;
    } else if (gameState.level === 56) {
        objDisplay.style.display = "block";
        objDisplay.innerText = `Prod: ${gameState.producedRaysCount}/750`;
    } else if ([17, 27, 31, 34, 39].includes(gameState.level)) {
        let max = 5;
        if(gameState.level === 27) max = 10; if([34, 39, 78].includes(gameState.level)) max = 15;
        objDisplay.style.display = "block"; objDisplay.innerText = `Bajas: ${gameState.heroesLostCount}/${max}`;
    } if (gameState.level === 32 || gameState.level === 49) {
      objDisplay.style.display = "block";
      objDisplay.innerText = `Kill Lejos: ${gameState.killObjCount}/10`;
    } if (gameState.level === 22) {
        limitDisplay.style.display = "block";
        limitDisplay.innerText = `Gasto: ${gameState.raysSpent}/40`;
    } else if (gameState.level === 23) {
        limitDisplay.style.display = "block";
        limitDisplay.innerText = `Gasto: ${gameState.raysSpent}/150`;
    } else if (gameState.level === 24 || gameState.level === 40 || gameState.level === 69) {
        limitDisplay.style.display = "block";
        limitDisplay.innerText = `H√©roes: ${heroes.length}/20`;
    } else if (gameState.level === 69) {
        limitDisplay.style.display = "block";
        limitDisplay.innerText = `H√©roes: ${heroes.length}/20`;
    }
    let enemyText = "";
    if (typeof gameState.level === 'number' && [10, 18, 36, 54, 86].includes(gameState.level)) enemyText = "Jefe";
    else enemyText = gameState.enemiesToSpawn + enemies.length;
    document.getElementById('enemies-display').innerText = enemyText;
    document.getElementById('level-display').innerText = gameState.level;
}

function retryLevel() {
    // Si es modo infinito, reintentar significa EMPEZAR DE NUEVO desde ola 1
    if (gameState.mode === 'infinite') {
        document.querySelectorAll('.screen, #overlay').forEach(el => { el.style.display = 'none'; });
        startInfiniteMode();
    } else {
        document.querySelectorAll('.screen, #overlay').forEach(el => { el.style.display = 'none'; });
        gameState.gameOver = false;
        prepareLevel(gameState.level);
    }
}

setInterval(() => {
    if(!gameState.gameOver && document.getElementById('gameCanvas').offsetParent !== null){
        gameState.timerRayo--;
        if(gameState.timerRayo <= 0){
            if (gameState.level !== 43) { gameState.rayos++; }
            gameState.timerRayo = 20;
            updateUI();
        }
    }
}, 1000);

loadProgress();
renderLevelGrid();

</script>
</body>
</html>
